> <이펙티브 타입스크립트>(댄 밴더캄 지음, 장원호 옭김, 인사이트, 2021)

### 2장 타입스크립트의 타입 시스템

- 타입스크립트의 두 가지 역할 "구버전의 JS로 트랜스파일", "코드의 타입 오류 체크" 중 타입 오류 체크가 타입스크립트를 사용하는 진정한 이유이다.

#### 아이템 6 - 편집기를 사용하여 타입 시스템 탐색하기
- 타입스크립트 편집기를 이용하면 타입스크립트가 특정 심벌을 어떻게 판단하는지 확인할 수 있다.
    - `let num = 10`으로 변수에 할당하면 편집기는 `number`로 추정한다.
    - 분기문에 따라서 타입이 어떻게 변하는지(추론하는지)도 살펴볼 수 있다.
- 타입 선언 파일을 찾아봄으로써, 타입스크립트가 동작을 어떻게 모델링하는지 알 수 있다.

#### 아이템 7 - 타입이 값들의 집합이라고 생각하기
- 변수에 할당할 수 있는 '할당 가능한 값들의 잡합'을 타입이라고 할 수 있다.

**집합의 범위**
> 하위로 갈 수록 범위가 커진다.
- 가장 작은 집합은 아무 값도 포함하지 않는 `never` 타입이다.
    - `let x: never;`
- 한 가지 타입만 포함하는 리터럴(literal) 타입이다. 유닛(unit) 타입이라고도 한다.
    - `type A = 'A';`
    - `type B = 'B';`
    - `type Twelve = 12;`
- 여러개의 타입을 묶으려면 유니온(union) 타입을 사용한다. 유니온 타입은 값들의 합집합이다.
    - `type AB = 'A' | 'B';`

**interface에서 `&` 연산자와 `|` 연산자**
- 타입 연산자는 인터페이스의 속성이 아닌 타입의 범위에 적용된다.
    - `&` 연산자는 두 타입의 교집합(intersection)을 계산한다.
    - `|` 연산자는 두 타입의 합집합(union)을 계산한다.
- 연산자의 적용
    - `keyof (A&B) = (keyof A) | (keyof B);`
    - `keyof (A|B) = (keyof A) & (keyof B);`

**extends**
- `extends`는 타입이 집합이라는 관점에서 '~의 부분 집합'이라는 의미로 받아들일 수 있다.
- `extends` 키워드는 제네릭 타입에서 한정자로도 쓰인다.
```ts
function getKey<K extends string>(val:any, key: K) {
    // ...
}
```

**Exclude**
- `Exclude`를 이용해서 일부 타입을 제외할 수도 있다.
- 문법은 `Exclude<T, U>`로 `T`에서 `U`에 포함되는 타입을 제외하겠다는 뜻이다.
    - `type Example = Exclude<string|Date, string|number>;` // 타입은 Date - U에 string 타입이 있으므로 T에서 string을 제외시켜 Date 타입만 남았다.
- `Exclude` 문법은 적절한 타입스크립트 타입일 때만 유효한다.
```ts
type NonZeroNums = Exclude<number, 0>; // 타입은 여전히 number
const zero: NonZeroNums = 0; // 에러가 발생하지 않는다.
```

#### 아이템 8 - 타입 공간과 값 공간의 심벌 구분하기
- 타입스크립트에서 타입인지 값인지 구분을 할 수 있어야한다.
    - 타입 선언(`:`) 또는 단언문(`as`) 다음에 나오는 심벌은 타입이다.
    - `=` 다음에 나오는 것은 값이다.
```ts
// 타입
type T1 = 'string literal';
type T2 = 123;
// 값
const v1 = 'string literal';
const v2 = 123;
```
- 자바스크립트로 컴파일되면 타입들은 사라진다.
```js
const v1 = 'string literal';
const v2 = 123;
```
- 타입스크립트와 자바스크립트에서 상황에 따라 다르게 사용되는 예약어를 조심해야 한다.
    - `class`가 타입으로 쓰일때는 형태(속성 & 메서드)가 사용되고, 값으로 쓰일 때는 생성자가 사용된다.
    - `typeof`는 타입에서는 값을 읽어서 타입스크립트 타입을 반환하고, 값에서는 런타임의 `typeof` 연산자가 된다.

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다.
    - `type`과 `interface` 키워드는 타입 공간에만 존재한다.

#### 아이템 9 - 타입 단언보다는 타입 선언을 사용하기

- 타입스크립트에는 두 가지 방식으로 변수에 값을 할당하고 타입을 부여한다.
    - 타입 선언(: Type)
    - 타입 단언(as Type)
- 타입 선언을 사용하는 것이 타입 단언을 사용하는 것 보다 낫다.
    - 타입 단언은 사용자가 타입스크립트 편집기 보다 더 타입을 잘안다고 확신할 때 사용하는 것이다. (`querySelector`를 사용할 때, 타입스크립트는 DOM에 접근할 수 없기때문에 타입 단언을 사용한다.)
    - 타입 단언은 강제로 타입을 지정함으로 타입 체커에게 오류를 무시하라고 명령하는 것이다.
    - 타입 단언을 사용하면 타입스크립트의 런타임 에러를 방지하는 기능 장점을 무시할 수 있다.
- 타입 단언은 서브타입일때만 가능하다 의도적일 때는 먼저 `unknown`으로 변환해야 한다.
    - `const el = document.body as unknown as Person;`
- `null`이 아님을 단언할 때는 접미사로 `!`를 붙히면 된다.
    - `const el = document.getElementById('foo')!`


#### 아이템 10 - 객체 래퍼 타입 피하기
- 자바스크립트는 의 Primitive 타입들은 메서드를 가지고 있지 않는다.
    - 메서드를 가지고 있는 '객체' 타입이 정의되어 있어 Primitive 타입을 래핑(wrap)하고, 메서드를 호출한다음 래핑한 객체를 삭제한다.
- 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링 한다. (undefined와 null은 객체 래퍼가 없다.)
    - string & String
    - number & Number
    - boolean & Boolean
    - symbol & Symbol
    - bigint & BigInt
- `string`은 `String`에 할당할 수 있지만, `String`은 `string`에 할당할 수 없다.
    - 그러므로 `const hi: String = 'hi'`는 에러가 발생하지 않는다.
- Primitive 타입을 객체 래퍼에 할당하는 구문은 오해하기 쉬워서 Primitive 타입을 할당하는 것이 명시적이다.

#### 아이템 11 - 잉여 속성 체크의 한계 인지하기
- 타입스크립트에서 잉여 속성 체크는 객체 리터럴을 변수에 할당하거나, 함수에 매개변수로 전달할 때 수행된다.
    - 할당 가능 검사와 체크 방식이 다르므로 정확하게 인지해야 한다.
    - "임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다"는 점을 인지해야 한다.
```ts
interface Room {
    numDoors: number;
    ceilingHeightFt: nuber;
}

const r: Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present', // 잉여 속성 체크를 통해 에러가 발생한다.
}

const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
};

const room: Room = obj; // 할당 가능 검사를 통과해서 에러가 발생하지 않는다.
```

#### 아이템 12 - 함수 표현식에 타입 적용하기
- 자바스크립트와 타입스크립트에서 함수 문장과 표현식을 다르게 인식한다.
    - 타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.
    - 함수의 매개변수부터 반환값까지 전체 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있기 때문이다.
    - 함수 구현부와 타입도 분리되어 있어 로직이 보다 분명해진다.
- 라이브러리에서 공통 함수 시그니처를 타입으로 제공하기도 한다.
- 다른 함수의 시그니처를 참조하려면 `typeof fn`을 사용하면 된다.

#### 아이템 13 - 타입과 인터페이스의 차이시그니처
- 타입스크립트에서 명명된 타입을(named type)을 정의하는 방법은 `type`과 `interface` 두 가지가 있다.

- `interface`와 `type` 선언의 비슷한 점
    - 잉여 속성 체크가 발생한다.
    - 인덱스 시그니처를 사용할 수 있다. [[TypeScript]인덱스 시그니처(Index Signature) 사용 방법 - DevStory](https://developer-talk.tistory.com/297)
    - 둘 다 함수 타입을 정의할 수 있다.
    - 둘 다 제네릭이 가능하다.
    - `interface`는 `type`을 확장할 수 있고, `type`은 `interface`를 확장할 수 있다.
    - 클래스를 구현(`implements`)할때 `type`과 `interface` 모두 사용할 수 있다.
- `interface`와 `type` 선언의 차이점
    - `type`에는 `union type`이 존재한다.
    - 튜플과 배열 타입은 인터페이스로 비슷하게 구현할 수 있지만 튜플에서 사용할 수 있는`concat`같은 메서드를 사용할 수 없다.
    - `interface` 에서는 선언 병합이 가능하다.

- `interface`와 `type` 중 무엇을 선택해야 할까?
    - 향후 보강의 가능성을 따져봐야 한다.
    - API에 대한 타입 선언을 작성할 때는 `interface`가 좋다.
        - API가 변경될 때 사용자가 `interface`를 통해 새로운 필드를 병합할 수 있기 때문이다.
    - 내부적으로 사용되는 타입은 병합이 발생하는 것은 잘못된 설계이므로 타입을 사용하는 것이 좋다.

---
### 참고자료
[타입스크립트 Exclude, Omit, Pick - ChanBlog](https://chanhuiseok.github.io/posts/ts-3/)