> <이펙티브 타입스크립트>(댄 밴더캄 지음, 장원호 옭김, 인사이트, 2021)

#### 아이템 19 - 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 타입스크립트가 타입을 추론할 수 있으면 타입 구문을 작성하지 않는 것이 좋다.
  - 불필요한 코드가 추가되어 가독성이 떨어진다.

**ex)**

```ts
let x: number = 12; // ❌ 12를 할당하는 순간 number로 추론 된다.
let x = 12; // ⭕

const axis1: string = 'x'; // 타입은 string
const axis2 = 'y'; // 타입은 "y" - 더 정확한 타입이다.
```

- 이상적인 경우는 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없는 것이다.
  - 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다.

**ex)**

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

#### 아이템 20 - 다른 타입에는 다른 변수 사용하기

- 변수의 값은 바뀔 수 있지만. 그 타입은 보통 바뀌지 않는다.
  - 서로 관련이 없는 값이 분리된다.
  - 변수명을 더 구체적으로 지을 수 있다.
  - 타입 추론을 향상시킨다. 타입 구문이 불필요해진다.
  - 타입이 더 간결해진다.
  - 상수로 값을 선언하게 된다.

```ts
// 잘못된 방식
let id = '12-34-56';
id = 123456; // ❌ Type 'number' is not assignable to type 'string';

// 옳은 방식
const id = '12-34-56';
const serial = 123456; ⭕
```

- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 하는 것이 좋다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 준다.
  - 함수의 반환값이 의도한 대로 반환되는지 알 수 있게 해준다.

#### 아이템 21 - 타입 넓히기

- 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다.
  - 타입스크립트가 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하는 과정을 '넓히기(widening)'라고 부른다.
- 타입 넓히기 과정은 예측하기 힘듬으로 제어할 수 있도록 해야한다.
  - `const`선언은 `let`으로 변수를 선언할때보다 더 좁은 타입이 된다.
  - 하지만 `const`선언으로 객체나 배열을 선언하면 각 요소를 `let`으로 할당한 것 처럼 된다.

```ts
const x = 'x'; // x의 타입은 'x'
let y = 'y'; // y의 타입은 string

const v = { x: 1 }; // v의 타입은 { x: number }
```

- 타입 추론의 강도를 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다.
  - 명시적 타입 구문 제공하기
  - 함수의 매개변수로 값을 전달하는 등의 추가적인 문맥 제공하기
  - const 단언문 사용하기 (`as const`)

#### 아이템 22 - 타입 좁히기

- 넓은 타입으로 부터 좁은 타입으로 진행하는 과정이다.
  **ex) if 분기문으로 타입 좁히기**

```ts
const el = document.getElementById('foo'); // 타입이 HTMLElement | null
if (el) {
  el; // 타입이 HTMLElement
} else {
  el; // 타입이 null
}
```

**ex) instanceof로 타입 좁히기**

```ts
function contains(text: string, search: string | RegExp) {
  if (search instanceof RegExp) {
    search; // 타입이 RegExp
    return !!search.exec(text);
  }
  search; // 타입이 string
  return text.includes(search);
}
```

**ex) 속성 체크로 타입 좁히기**

```ts
interface A {
  a: number;
}
interface B {
  b: number;
}
function pickAB(ab: A | B) {
  if ('a' in ab) {
    ab; // 타입이 A
  } else {
    ab; // 타입이 B
  }
  ab; // 타입이 A | B
}
```

- 이외에도 `typeof`, `Array.isArray` 로도 타입 좁히기를 할 수 있다.

- 사용자 정의 타입 가드
  - 커스텀 함수로 타입 좁히기를 하는 것을 '사용자 정의 타입 가드'라고 한다.

```ts
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}

const members = ['Janet', 'Michael']
  .map((who) => jackson5.find((n) => n === who))
  .filter(isDefined);
```

#### 아이템 23 - 한꺼번에 객체 생성하기

- 타입스크립트에서 객체를 생성할때는 한번에 생성하는 것이 타입 추론에 유리하다.

```ts
const obj = {};
obj.x = 1;
// ~ '{}' 형식에 'x' 속성이 없습니다.
```

- 객체를 나눠서 만들어야 한다면 타입 단언문을 사용해서 타입 체커를 통과할 수 있다.

- `spread`연산자를 사용하면 객체를 한번에 만들 수 있다.

```ts
const obj1 = { x: 1 };
const obj2 = { y: 2 };
const assingedObj = { ...obj1, ...obj2 };
assignedObj.x; // 1
```
