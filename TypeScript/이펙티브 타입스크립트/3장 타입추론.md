> <이펙티브 타입스크립트>(댄 밴더캄 지음, 장원호 옭김, 인사이트, 2021)

#### 아이템 19 - 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 타입스크립트가 타입을 추론할 수 있으면 타입 구문을 작성하지 않는 것이 좋다.
    - 불필요한 코드가 추가되어 가독성이 떨어진다.

**ex)**
```ts
let x: number = 12; // ❌ 12를 할당하는 순간 number로 추론 된다.
let x = 12; // ⭕

const axis1: string = 'x'; // 타입은 string
const axis2 = 'y'; // 타입은 "y" - 더 정확한 타입이다.
```

- 이상적인 경우는 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없는 것이다.
    - 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다.

**ex)**
```ts
interface Product {
    id: number;
    name: string;
    price: number;
}

function logProduct(product: Product) {
    const {id, name, price} = product;
    console.log(id, name, price)
}
```

#### 아이템 20 - 다른 타입에는 다른 변수 사용하기
- 변수의 값은 바뀔 수 있지만. 그 타입은 보통 바뀌지 않는다.
    - 서로 관련이 없는 값이 분리된다.
    - 변수명을 더 구체적으로 지을 수 있다.
    - 타입 추론을 향상시킨다. 타입 구문이 불필요해진다.
    - 타입이 더 간결해진다.
    - 상수로 값을 선언하게 된다.
```ts
// 잘못된 방식
let id = '12-34-56';
id = 123456; // ❌ Type 'number' is not assignable to type 'string';

// 옳은 방식
const id = '12-34-56';
const serial = 123456; ⭕
```


- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 하는 것이 좋다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 준다.
    - 함수의 반환값이 의도한 대로 반환되는지 알 수 있게 해준다.