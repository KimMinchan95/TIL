# Node.js 등장배경, 실행방식

[[10분 테코톡] 유세지의 Node.js](https://www.youtube.com/watch?v=A04zlpL1Uw4&list=PLkfxusmKmLsNDGmER2tmrslpPOTfKhE7j&index=107&t=440s)

## Node.js란?

> 자바스크립트를 실행시키는 런타임 환경
> 
- 런타임 환경 : 특정 언어로 만든 프로그램을 실행할 수 있도록 해주는 프로그램

**자바스크립트가 등장했을때는 브라우저에 종속되어 있었다.**

- 이전에도 브라우저이외의 환경에서 JS를 실행시키려는 시도가 많았지만 매우 느렸다.
- 그러다  구글에서 V8엔진을 탑재한 크롬 브라우저를 출시했다.
    - 크롬 브라우저는 전보다 훨씬 빠른 속도로 JS코드를 실행했다.
    - Ryan Dahl이 V8 엔진을 기반으로 하는 런타임인 Node.js를 만들었다.

## Node.js 특성

> 비동기 이벤트 주도 JavaScript 런타임으로써 Node.js는 확장성 있는 네트워크 애플리케이션을 만들 수 있도록 설계되었다. - Node.js 공식 문서
> 

- 비동기 이벤트 주도
    - 이벤트가 발생하게 되면 우리가 지정한 어떤 작업이 수행되는 방식을 말한다.
- Single Thread를 효율적으로 사용하는 Event Loop 방식 채택

![Event Loop](https://user-images.githubusercontent.com/83770790/180446845-b7342eca-dbfa-4d41-acb4-569ce539ec8f.png)


- 위에서 부터 실행이 되고, 각 단계는 큐와 비슷한 구조로 이루어져 있다.
    - 각 단계들 마다 특정 시간을 할당해서 그 시간만큼 작업을 처리하는 라운드 로빈방식으로 처리한다.
    - 각 단계가 갖고 있던 콜백을 모두 실행해서 처리하면 다음단계로 넘어간다. 이것을 Tick이라고 부른다.
    - 각 단계는 서로 다른 종류의 콜백들을 담당하기 때문에 어떤 동작을 갖은 콜백을 이벤트 루프에 넣었는지에 따라서 어느 큐로 들어갈지 결정된다.
    
- Timers 단계
    - `setTimeout()`, `setInterval()`
    - 타이머 함수로 스케줄링한 콜백들이 들어간다.
    
- Pending callbacks
    - `CONNECTION_ERROR`
    - 이전 루프에서 마무리 되지 못한 I/O 콜백들
    
- Idle, prepare 단계
    - 내부의 작업 수행, I/O 폴링 사전 준비
    - 내부적인 작업을 위해서만 이용이되고, 외부에 노출이 되지 않는다.
    - 개발자가 직접 이 단계의 작업을 지정해주는 경우는 거의 없다.
    
- Poll 단계
    - 새로운 I/O 이벤트를 가져와서 실행한다.
    - 파일을 읽고 쓰거나 네트워크와 통신하는 등 일을 수행한다.

- Check 단계
    - `setImmediate()`
    - poll단계에 큐가 비어있고 유휴 상태(Idle)이 되었을때 `setImmediate()`로 스케줄링된 콜백이 존재한다면 바로 Check 단계로 넘어온다.
    
- Close 단계
    - close 콜백 실행 (소켓 종료)

### Node.js Event Loop vs Browser Event Loop

- 개념적으로 같지만 세부적인 부분에서 차이가 존재한다.
    - `setImmediate()` 같은 경우도 Node만의 API이다.
        - IE와 Edge의 초반 부분에는 `setImmediate()`가 존재한다.
    - `Process.nextTick`은 Node에만 존재하는 API다.
        - 루프의 특정 단계가 아니라 단계와 단계 사이에서 실행된다.

### None blocking I/O 모델

> Node.js에서 I/O를 직접 수행하는 함수는 거의 없으므로 프로세스는 블로킹 되지 않는다. 그러므로 Node.js에서는 확장성 있는 시스템을 개발하는 게 아주 자연스럽다. - Node.js 공식 문서
> 

- JS는 싱글 스레드의 언어여서 논 블로킹 모델은 필수적이다.
    - 만약 블로킹 모델이면 작업이 완료되지 않으면 다음 단계로 넘어가지 못한다.

### 자바스크립트는 싱글 쓰레드 언어인데 비동기 작업은 어떻게 실행할까?

- 여기서의 Callback들은 Event Loop로 간다.

![Node js 엔진](https://user-images.githubusercontent.com/83770790/180446859-127e665e-3e11-4060-a86c-0a69254e0246.png)


**위의 사진은 Node.js의 내부구조이다**

- Node.js Bindings는 API를 바인딩해준다.
- libuv
    - Node에 포함되어서 각종 비동기 작업들을 포함해서 다양한 작업을 수행하는 C 기반의 라이브러리이다.

![libuv](https://user-images.githubusercontent.com/83770790/180446873-54346ab0-909b-4e87-8bc6-def12afeacd9.png)


- 기본적인 I/O에 대한 API와 기타 작업을 위한 자체 쓰레드 풀을 가지고 있다.
    - 기본적으로 네 개의 쓰레드를 쓰레드 풀에 할당한다.
    - 이벤트 루프에 던져진 비동기 작업들은 일반적으로 libuv 내부가 아닌 시스템 커널에서 수행된다.

---

### 용어정리

- I/O 입력(Input)/출력(Output)의 약자이다. 컴퓨터와 데이터를 주고받는 연산이나, 프로그램 또는 장치를 가리킨다.
- 블로킹 / 논블로킹
    - 다른 작업을 수행하는 주체를 어떻게 생대하는지가 중요하다.
    - 블로킹 : 자신의 작업을 하다가 다른 작업 주체가 하는 직업의 시작부터 끝까지 기다렸다가 다시 자신의 작업을 시작한다면 블로킹 (제어권을 넘겨준다.)
    - 논 블로킹 : 다른 주체의 작업과 관계없이 자신의 작업을 계속한다면 논블로킹 (제어권을 자신이 가지고 있는다.)
