# 프론트엔드에서의 에러 핸들링

[[10분 테코톡] 🌼 티케의 프론트엔드에서의 에러 핸들링](https://www.youtube.com/watch?v=FXtooPhupr4&list=PLkfxusmKmLsNDGmER2tmrslpPOTfKhE7j&index=87)

## 1. 용어 정의

### 에러(오류)란?

- 에러(오류)
    - 사전적 정의 : 실패, 실수 또는 오차를 의미
    - 프로그래밍 : 하드웨어의 고장 또는 소프트웨어가 본래의 동작을 할 수 없는 상태
- 소프트웨어의 오류
    - 발생하는 시점을 기준으로 컴포일 에러와 런타임 에러로 나눌 수 있다.
        - 컴파일 에러 : 문법을 잘못 작성하는 등 코드가 작성될 때 컴파일러가 해석하지 못 해서 발생하는 에러를 의미한다.
        - 런타임 에러 : 프로그램이 동작할 때 발견할 수 있는 에러이다.
        쉽게 try-catch에서 잡히는 에러를 의미한다.
        - JavaScript에서는 런타임 에러를 예외라고 부른다.

### JavaScript와 컴파일 오류

- JS는 Dynamic Typed Language이기 때문에 프로그램이 동작할때 실시간으로 Type이 결정되어서 모든 에러가 컴파일 단계가 아닌 런타임 환경에서 발생할 수 있다.
- 이로인해 코드를 작성하면서 잡을 수 있는 에러임에도 불구하고 사용자가 App을 사용할때 발견할 수도 있다.
- 이로인해 컴파일 환경에서 타입에 관련된 에러를 잡을 수 있도록 도와주는 Statically Typed Language인 TypeScript를 사용하는 것이다.

 

### 예외란?

- 예외
    - 사전적 정의 : 일반적인 규칙이나 정례에서 벗어나는 일
    - 프로그래밍 : 런타임 오류와 관련된 것, 예상하기 어렵거나 예상이 불가능한 이슈를 의미
- 예상이 어렵거나 불가능한 이슈
    - 오류가 발생할 가능성이 있는 구문을 ‘예외’ 구문으로 처리하여 프로그램이 예상치 못하게 종료되거나 제 기능을 못하는 것을 방지해야 한다.
    - 예외로 인해 발생한 **Error 객체**를 핸들링하는 것을 **에러핸들링**이라고 한다.
    - JS에서의 에러라고 하면 보통 **예외**를 의미한다.

## 2. 에러핸들링이 필요한 이유

- 만약 에러가 발생했는데 사용자가 인지를 못한다면 에러인지도 모른채 계속 로딩을 기다릴 수도 있음.
    - 에러에 대한 인지를 시키기, 다른 행동을 할 수 있도록 유도
    - ⇒ 서비스에 대한 부정적인 경험을 막을 수 있음
    - 서비스의 트렌젝션에 영향을 미쳐 **장애를 일으킬 수 있는 상황이 발생하는 것을 막아야됨**

## 3. 에러의 분류

### 예상이 가능한 에러

- 인증에러
- 없는 페이지를 접근했을 때의 에러
- 어플리케이션에서 정의한대로 API 응답의 상태 코드로 예측할 수 있는 에러
- 악의적인 목적으로 접근했을 때 이를 보완하는 코드가 프로그램에 내제되어 있지 않는 경우

### 예상이 불가능한 에러

- 서비스 장애
- 일시적인 네트워크가 불안정한 상황에서 발생하는 에러
- 500대 에러(서버 오류)

## 4. 에러핸들링 예시

### 예상이 가능한 에러

- API 오류 컨벤션을 통한 에러 예상과 try-catch구문을 통한 핸들링
- 잘못된 페이지나 없는 페이지를 접근할 경우 404 커스텀 페이지를 생성하거나, 다른 페이지로 리다이렉트하게 만들 수 있다.

### 예상이 불가능한 에러

- 일시적인 에러일 경우 알리기
- 고객센터에 연락할 수 있는 창구 마련하기

## 5. 에러핸들링에 대한 고찰

### 무조건 try-catch하는 것을 지양

- catch에 넘겨지는 error 객체의 타입을 보장할 수 없음 (분기 처리를 모두 하지 않았으면 어떤 에러인지 알 수 없음)
- 모든 예외 상황에 대해 catch 했을 경우 오류를 해결하는 것이 아니라 사용자에게 숨기는 행위일 수 있음

 

### 좋은 try-catch 예시

> 성공하는 여부에 대해서만 다루고, 실패하는 경우는 외부에 위임
> 
- 유의미한 에러를 내보낼 수 있는 범위에서 에러핸들링
- 유의미한 결과를 내보낼 수 없다면 에러를 터트리고, 원인을 찾고 고치는게 유지보수성을 높이고 견고한 코드를 만들자.

```jsx
const checkAuth = async (accessToken) => {
	const user = await login(accessToken);
	const role = await getRole(user);
	return role;
}

const UserPage = () => {
	// ...
	
	try {
		checkAuth(accessToken);
	} catch (error) {
		console.error(ERROR_MESSAGE[error.code] ?? ERROR_MESSAGE.DEFAULT);
	}
}
```