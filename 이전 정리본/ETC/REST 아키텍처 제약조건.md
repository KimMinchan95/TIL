# REST 아키텍처 제약 조건

### REST 아키텍처의 기본 원칙 또는 제약 조건은 6가지가 있다.

1. Uniform Interface
2. Client-Server
3. Statless
4. Cacheable
5. Layered System
6. Code on Demand (Optional)

### 1. Uniform Interface

**1. identification of resources**
- 자원에 대한 식별
    - 자원은 객체
    - 상태는 변화가능! → 변하지 않는 식별자 필요!
    - **URI를 통해 자원을 식별해야 한다.**
**2. manipulation of resources through representations**
- 표현을 통한 자원에 대한 조작
    - 표현: 특정한 상태의 자원에 대한 표현
    - 자원은 다양한 방식으로 표현 가능
- 표현된 자원의 상태
    - 자원의 현재 상태
    - 자원의 기대되는 상태
**3. self-descriptive messages**
- 자기 서술적 메세지
    - 메시지는 스스로에 대해 설명해야 한다.
    - 클라이언트와 서버 사이의 컴포넌트들은 메시지의 내용을 참고하여 적절한 작업 수행!
    - 중개자들에게 자신을 어떻게 처리해야 한다는 것을 정확하게 설명해야 한다.
- Host 헤더
    - Host 헤더에 도메인명 기재 필요 (HTTP/1.1부터 Host 헤더 필수화)
    - 도메인명 정보의 필요성
        - 가상호스트 문제
        - 하나의 IP주소에 복수의 도메인명 존재 가능
        - IP 주소만으로는 요청 대상을 찾아낼 수 없다.
            - ex) IP 주소: 125.209.222.141, 도메인명: https://www.naver.com
- 캐시
    - 캐쉬 관련 헤더를 통한 캐쉬 전략 지정
    - 개별 요청의 경우 서버와 클라이언트 사이에 특정 컴포넌트에 특정 컴포넌트에 캐시해 놓는경우, 두 번째 요청부터는 해당 컴포넌트로 부터 응답을 전달받는다.
    - 컴포넌트들이 참고할 수 있도록 적절하게 설명해야 한다.

**4. HATEOAS(hypermedia as the engines of application state)**
- 하이퍼미디어를 통한 앱 상태 변경
    - HTML과 같은 하이퍼미디어를 통해 클라이언트가 애플리케이션의 상태를 변경할 수 있는 인터페이스를 제공해야 한다.
    - 접근할 수 없는 숨겨진 페이지가 존재하면 이 조건에 위배된다.

**REST API여야 하는가?**

- Uniform Intrface 제약조건은 비효율적
- 애플리케이션에 필요한 정보가 아니라, 표준화된 형식으로 데이터 전달 강요
- 상황에 따라서 최적이 아닐 수도 있다.

### 2. Cleint-Server

- 관심사 분리에 대한 내용이다.
- 클라이언트 - 서버 디자인 패턴은 관심사 분리를 적용하여 클라이언트와 서버 구성요소가 독립적으로 발전하는데 도움이 된다.
- 사용자 인터페이스 문제(클라이언트)와 데이터 저장소 문제(서버)를 분리하여 여러 플랫폼에서 사용자 인터페이스의 이식성을 개선하고 서버 구성 요소를 단순화하여 확장성을 개선한다.
- 클라이언트와 서버가 진화하는 동안 클라이언트와 서버 간의 인터페이스/협약이 깨지지 않도록 해야한다.

### 3. Stateless

- 무상태성
- 무상태성에서는 클라이언트에서 서버로 보내는 각 요청이, 서버가 이해할 수 있는 완전한 정보를 포함하고 있어야한다.
- 서버는 이전에 저장된 컨텍스트(누가 무엇을 어떤 의도를 가지고 언제 행위를 하였는지에 대한 정보) 정보를 이용할 수 없다.
- 이러한 이유로 클라이언트 애플리케이션은 세션 상태(서버가 식별할 수 있게)를 유지해야 한다.

### 4. Cacheable

- 캐시 가능(Cacheable) 제약 조건은 응답이 암시적 또는 명시적으로 캐시 가능 or 캐시 불가능으로 스스로 명세해 줘야 한다.
- 캐시 가능으로 지정되어 있을 경우 클라이언트 애플리케이션은 나중에 동등한 요청 및 지정된 기간 동안 응답 데이터를 재사용할 수 있는 권한을 얻는다.
- `cache-control` 헤더를 통해 캐시 여부를 명시해줘야 한다.
- `Last-Modified`, `E-Tag`를 이용하여 캐시 구현이 가능하다.
    - Last-Modified: 브라우저가 서버로 요청한 파일의 최종 수정 시간을 알려주는 헤더
    - E-Tag: 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.

### 5. Layered System

- 서버는 중개 서버(게이트웨이, 프록시)나 로드 밸런싱, 공유 캐시 등의 기능을 사용하여 확장성 있는 시스템을 구성할 수 있다.

### 6. Code on Demand (Optional)

- 클라이언트는 서버에서 애플릿 or 스크립트 형태의 코드를 다운로드하고 실행하여 기능을 확장 할 수 있다.
- 다운로드한 코드는 미리 구현해야 하는 기능의 수를 줄여 클라이언트를 단순화 한다.
- 서버는 클라이언트에게 전달되는 기능의 일부를 코드 형태로 제공할 수 있으며 클라이언트는 코드를 실행하기만 하면 된다.

---

## 참고자료

[[10분 테코톡] 정의 REST API](https://www.youtube.com/watch?v=Nxi8Ur89Akw&t=625s)

[What is REST - REST API Tutorial](https://restfulapi.net/)

[REST Architectural Constraints](https://restfulapi.net/rest-architectural-constraints/)

[RESTful API 6가지 제약 조건](https://rutgo-letsgo.tistory.com/158)