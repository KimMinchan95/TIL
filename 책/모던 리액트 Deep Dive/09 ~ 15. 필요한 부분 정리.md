# 09 ~ 15는 지금 당장 필요하지 않은 부분들이 많아서 책은 다 읽되 필요한 부분만 정리할 예정

## 09.모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

### create-next-app 없이 하나씩 구축하기

- `package.json` 만들기
  - `npm init`을 실행하면 `package.json`을 만드는 CLI를 실행할 수 있다.
  - Next.js 프로젝트를 실행하는데 필요한 핵심 라이브러리인 `react`, `react-dom`, `next`를 설치한다.
  - devDependencies에 필요한 `typescript`, `@types/react`, `@types/react-dom`, `@types/node` 그리고 ESLint에 필요한 `eslint`, `eslint-config-next`를 설치한다.
- tsconfig.json 작성하기
  - 타입스크립트 설정을 기록한다.
  - JSON 파일 최상단에 `$schema` 키와 값을 넣으면 해당 JSON 파일이 무엇을 의미하는지, 어떤 키와 값이 들어갈 수 있는지 알려준다. (.eslintrc, .prettierrc 같은 JSON 방식으로 설정을 작성하는 라이브러리가 schemastore에 해당 내용을 제공하고 있다면 편리하게 JSON 설정을 작성할 수 있다.
- next.config.js 작성하기
  - Next.js 설정을 위한 next.config.js를 만든다.
  - 버전별로 설정이 조금씩 다르므로 본인이 사용하고 있는 next.config.js에서 사용 가능한 옵션을 확인하기 위해 깃허브 저장소를 방문해야 한다.
- ESLint와 Prettier 설정하기
- 스타일 설정하기
- 애플리케이션 코드 작성

- 깃 허브에서 제공하는 기본 액션
  - `action/checkout` - 깃허브 저장소를 체크아웃 하는 액션
  - `actions/setup-node` - Node.js를 설치하는 액션
    - 설치할 Node.js버전을 지정할 수도 있다.
  - `actions/github-script` - GitHub API가 제공하는 기능을 사용할 수 있도록 도와주는 액션
  - `actions/stale` - 오랜된 이슈나 PR을 자동으로 닫거나 더 이상 커뮤니케이션하지 못하도록 닫는다.
  - `actions/dependency-review-action` - 의존성 그래프에 대한 변경 등의 내용이 변경되었을 때 실행되는 액션으로, 의존성을 분석해 보안 또는 라이센스에 문제가 있다면 이를 알려준다.
  - `github/codeql-action` - 깃허브의 코드 분석 솔루션인 code-ql을 활용해 저장소 내 코드의 취약점을 분석해 준다.
- `calibreapp/image-actions`
  - pr로 올라온 이미지를 sharp패키지를 이용해 거의 무손실 압축해서 다시 커밋해 준다.
- `Lighthouse CI`
  - 구글에서 제공하는 액션으로 라이트하우스를 CI기반으로 실행할 수 있도록 도와주는 도구이다.

### package.json의 dependencies 이해하기

- 버전
  - 주 (Major) : 기존 버전과 호환되지 않게 API가 바뀌면 주 버전을 올린다.
  - 부 (Minor) : 기존 버전과 호환되면서 새로운 기능을 추가할 때는 부 버전을 올린다.
  - 수 (Patch) : 기존 버전과 호환되면서 버그를 수정한 것이라면 수 버전을 올린다.
- npm 의 버전
  - react@16.0.0 : 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존한다.
  - react@^16.0.0 : 16.0.0과 호환되는 버전을 의미한다. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정하에 상위 버전을 설치할 수 있다는 것을 의미한다. (16.0.0 ≤ 버전 < 17.0.0)
  - react@~16.0.0 : 패치 버전에 대해서만 호환되는 버전을 의미한다. (16.0.0 ≤ 버전 < 16.1.0)

### 의존성

- dependencies : `npm install 패키지명`을 실행하면 dependencies에 추가된다. 해당 프로젝트를 실행하는데 꼭 필요한 패키지가 여기에 선언된다.
- devDependencies : package.json에서 `npm install 패키지명 --save-dev`를 실행하면 devDependencies에 추가된다. 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 필요한 패키지들을 여기에 선언한다.
- peerDependencies : 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위다. 패키지를 require하거나 import하지는 않지만 호환성으로 인해 필요한 경우를 의미한다.

  - 예시)

  ```tsx
  {
  	"peerDependencies": {
  		"react": ">=16.8",
  		"react-dom": ">=16.8"
  	}
  }
  ```

- 의존성 관련 이슈를 방지하는 가장 좋은 방법은 의존성을 최소한으로 유지하는 것이다.
  - 바깥에 노출되는 면적이 클수록 위협에 노출되는 확률이 커지는 것과 마찬가지로 의존성, 즉 dependencies와 node_modules의 크기가 커질수록 위협에 노출될 확률 또한 높아진다.
  - 의존성을 최소화할 수 없다면, 내재화할 수 있는 모듈이 많지 않다면 가능한 한 널리 알려져 있고 많은 사람들이 사용하는 그리고 활발하게 유지보수되는 패키지를 사용해야 한다. 유지보수하는 주체가 없으면 점차 의존성 문제에 당면할 가능성이 크다.

# 10. 리액트 17과 18의 변경사항 살펴보기

## 리액트 17 버전 살펴보기

- 리액트 17 버전 부터는 점진적인 업그레이드가 가능하다.
    - 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 복잡성이 증가한다.
    - 점진적인 업그레이드를 채택하기 위해서라도 반드시 리액트 버전 17까지는 업그레이드 할 필요가 있다.
- 이벤트 위임 방식 변경
    - 사전지식
        - 캡처(capture) : 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타겟 타겟 요소까지 내려가는 것을 의미한다.
        - 타겟(target): 이벤트 핸들러가 타겟 노드하는 단계. 이 단계에서 이벤트가 호출된다.
        - 버블링(bubbling) : 이벤트가 발생한 요소에서 부터 시작해 최상단 요소까지 다시 올라간다.
    - 리액트의 이벤트 처리방식
        - 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. (이벤트 위임)
        - 이벤트 위임을 통해 ul의 자식에 li가 추가 또는 삭제되더라도 이벤트 핸들러도 똑같이 추가 수정할 필요도 없고, 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있다.
        - 리액트 17부터는 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리(루트) 요소로 바뀌었다. (점진적 업그레이드 지원, 바닐라 JS, jQuery 등이 혼재 돼 있는 경우 혼란 방지)
- 새로운 JSX transform
    - 16 버전 까지는 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라고 `import React from 'react'`가 필요했다.
    - 17 버전 부터 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있게 됐다.
- 이벤트 풀링 제거
    - 리액트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 객체다.
    - 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했고, 메모리 할당 작업이 일어나야 했고, 메모리 누수 방지를 위해 주기적으로 해제해야 했다.
- useEffect 클린업 함수의 비동기 실행
    - 16 버전 까지는 useEffect에 있는 클린업 함수를 동기적으로 처리했다.
    - 17 버전 부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다. - 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다. (커밋 타임이 조금이나마 빨라진다.)

## 리액트 18버전 살펴보기

- 새로 추가된 훅
    - `useId` - 컴포넌트 별로 유니크한 값을 생성
        - 서버 사이드 렌더링 환경에서 id는 서버와 클라이언트에서 동일한 값을 가져야 한다.
        - `useId` 를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부에 고유한 값을 생성할 수 있다.
    - `useTransition` - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
        - 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.
        - startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다. 경우에 따라서 여러 개의 setter를 넣어줄 수도 있다.
        - 리액트 18의 변경 사항의 핵심 중 하나인 ‘동시성(concurrency)’를 다룰 수 있는 새로운 훅이다.
        - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.
    - `useDeferredValue` - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
        - 디바운스와 비슷하지만, 디바운스는 고정된 지연시간이 필요하지만 useDefferedValue는 첫 번째 렌더링이 완료된 이후에 지연된 렌더링을 수행 한다.
        - useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하지만, useDeferredValue는 state 값 자체만을 감싸서 사용한다. (사용하는 방법만 다를 뿐 동일한 역할을 한다.)
        - props와 같이 상태 업데이트에 관여할 수 없는 경우 useDeferredValue를 사용하는 것이 타당하다.
    - `useSyncExternalStore` - 데이터의 불일치가 일어나는 tearing 현상을 해결한다.
        - 리액트가 관리할 수 없는 리액트 클로저 밖에있는 document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부상태관리 라이브러리등에 영향을 받을 때 useTransition이나 useDefferedValue 같이 ‘양보’하는 일이 일어나는 경우 데이터 불일치를 방지한다.
    - `useInsertionEffect` -
        - 기본 구조는 useEffect와 동일하지만, 실행 시점이 DOM이 실제로 변경되기 전에 동기적으로 실행된다. - 브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 되게 한다.
        - 실행 순서
            
            ```jsx
            useEffect(() => {}) // 3
            useLayoutEffect(() => {}) // 2
            useInsertionEffect(() => {}) // 1
            ```
            

### react-dom/client

- createRoot - react-dom의 `render` 를 대체할 새로운 메서드
- hydrateRoot - 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드

### react-dom/server

- renderToPipeablestream - 리액트 컴포넌트를 HTML로 렌더링하는 메서드
    - 스트림을 지원하는 메서드, HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다. 서버에서 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있다.
- renderToReadableStream - 웹 스트림을 기반으로 작동한다. 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드다.

### 자동 배치(Automatic Batching)

- 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.
- 리액트 17이하의 과거 버전에서는 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만 Promise, setTimeout 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았다.
    - 동기와 비동기 배치 작업에 일관성이 없었다.
- 리액트 18 버전부터는 루트 컴포넌트를 createRoot를 이용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됐다.
- 자동 배치를 리액트 18에서 하고 싶지 않거나 기존 코드에 영향을 미치면 `flushSync`를 사용하면 된다.
    - `flushSync`는 react가 아닌 react-dom 에서 제공 된다.

### 더욱 엄격해진 엄격 모드

- 리액트의 엄격 모드
    - 엄격 모드란?
        - 리액트에서 제공하는 컴포넌트 중 하나로, 잠재적인 버그를 찾는 데 도움이 된다.
        - 엄격 모드에서 수행하는 모드는 개발자 모드에서만 작동한다.
    - 기능
        - 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
        - 문자열 ref 사용 금지
            - 문자열로 값을 주면 여러 컴포넌트에서 사용할 수 있어서 충돌의 여지가 있다.
            - 단순한 문자열로 어떤 ref에서 참조되고 있는지 파악하기 어렵다.
            - 리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref를 추적해야 하기 때문에 성능 이슈가 있다.
        - findDOMNode 에 대한 경고 출력
            - class형 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 현재는 사용하는 것이 권장되지 않는 메서드다.
            - 부모가 특정 자식만 별도로 렌더링하는 것이 가능해서 리액트가 추구하는 트리 추상화 구조를 무너뜨린다.
            - 일회성 API라는 특징 때문에 자식 컴포넌트가 특정 시점에서 다른 노드를 렌더링할 경우 변경 사항을 추적할 수 없다.
        - 구 Context API 사용시 발생하는 경고
            - childContextType와 getChildContext를 사용하는 구 리액트 Context API를 사용하면 에러를 출력 한다.
        - 예상치 못한 side-effects 를 검사한다.
            - 함수형 컴포넌트의 body, useState, useMemo, useReducer에 전달되는 함수를 검사한다.
        - 두 번씩 실행
            - 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정. 엄격 모드에서 항상 순수한 결과물을 내고 있는지 개발자에게 확인
- Suspense 기능 강화
    - Suspense는 React.lazy를 통해 지연시켜 불로온 컴포넌트를 렌더링하는 역할을 한다. 지연 컴포넌트를 로딩하기 전에 fallback을 보여주고, 지연 로딩이 완료되면 해당 컴포넌트를 보여준다.
    - 리액트 18 이전의 Suspense의 문제점
        - 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
        - Suspense는 서버에서 사용할 수 없었다.
    - 수정 사항
        - 컴포넌트가 실제로 화면에 노출될 때 effect가 실행된다.
        - 서버에서도 실행할 수 있게 되었다.
        - 스로틀링이 추가되었다. 중첩된 Suspense의 fallback에 있다면 자동으로 스로틀이 되어서 최대한 자연스럽게 보여준다.
- 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요
- 그 밖에 변경사항
    - 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다.  null 반환과 동일하게 처리한다.
    - renderToNodeStream이 지원이 중단되고 renderToPipeableStream을 사용하는 것이 권장된다.

## 11. Next.js 13과 리액트 18

### app 디렉터리의 등장

- Next.js 12 버전까지는 무언가 페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다.
    - 이러한 레이아웃 한계를 극복하기 위해 나온 것이 app 레이아웃이다.
- 라우팅
    - `/pages` 로 정의하던 라우팅 방식이 `/app` 디렉터리로 이동했다.
    - `layout.js` - 루트에는 단 하나의 layout을 만들어 둘 수 있다. 모든 페이지에 영향을 미치는 공통 레이아웃이다.
    - `page.js` - Next.js에서 일반적으로 다뤘던 페이지를 의미한다.
    - `error.js` - 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다.
    - `not-found.js` - 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.
    - `loading.js` - Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낸다.
    - `route.js` - 라우팅 주소를 담당하며 파일명은 route.js로 통일되었다.
        - REST APi의 메서드명을 예약어로 선언해주면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.