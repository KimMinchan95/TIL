# 09 ~ 15는 지금 당장 필요하지 않은 부분들이 많아서 책은 다 읽되 필요한 부분만 정리할 예정

## 09.모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

### create-next-app 없이 하나씩 구축하기

- `package.json` 만들기
  - `npm init`을 실행하면 `package.json`을 만드는 CLI를 실행할 수 있다.
  - Next.js 프로젝트를 실행하는데 필요한 핵심 라이브러리인 `react`, `react-dom`, `next`를 설치한다.
  - devDependencies에 필요한 `typescript`, `@types/react`, `@types/react-dom`, `@types/node` 그리고 ESLint에 필요한 `eslint`, `eslint-config-next`를 설치한다.
- tsconfig.json 작성하기
  - 타입스크립트 설정을 기록한다.
  - JSON 파일 최상단에 `$schema` 키와 값을 넣으면 해당 JSON 파일이 무엇을 의미하는지, 어떤 키와 값이 들어갈 수 있는지 알려준다. (.eslintrc, .prettierrc 같은 JSON 방식으로 설정을 작성하는 라이브러리가 schemastore에 해당 내용을 제공하고 있다면 편리하게 JSON 설정을 작성할 수 있다.
- next.config.js 작성하기
  - Next.js 설정을 위한 next.config.js를 만든다.
  - 버전별로 설정이 조금씩 다르므로 본인이 사용하고 있는 next.config.js에서 사용 가능한 옵션을 확인하기 위해 깃허브 저장소를 방문해야 한다.
- ESLint와 Prettier 설정하기
- 스타일 설정하기
- 애플리케이션 코드 작성

- 깃 허브에서 제공하는 기본 액션
  - `action/checkout` - 깃허브 저장소를 체크아웃 하는 액션
  - `actions/setup-node` - Node.js를 설치하는 액션
    - 설치할 Node.js버전을 지정할 수도 있다.
  - `actions/github-script` - GitHub API가 제공하는 기능을 사용할 수 있도록 도와주는 액션
  - `actions/stale` - 오랜된 이슈나 PR을 자동으로 닫거나 더 이상 커뮤니케이션하지 못하도록 닫는다.
  - `actions/dependency-review-action` - 의존성 그래프에 대한 변경 등의 내용이 변경되었을 때 실행되는 액션으로, 의존성을 분석해 보안 또는 라이센스에 문제가 있다면 이를 알려준다.
  - `github/codeql-action` - 깃허브의 코드 분석 솔루션인 code-ql을 활용해 저장소 내 코드의 취약점을 분석해 준다.
- `calibreapp/image-actions`
  - pr로 올라온 이미지를 sharp패키지를 이용해 거의 무손실 압축해서 다시 커밋해 준다.
- `Lighthouse CI`
  - 구글에서 제공하는 액션으로 라이트하우스를 CI기반으로 실행할 수 있도록 도와주는 도구이다.

### package.json의 dependencies 이해하기

- 버전
  - 주 (Major) : 기존 버전과 호환되지 않게 API가 바뀌면 주 버전을 올린다.
  - 부 (Minor) : 기존 버전과 호환되면서 새로운 기능을 추가할 때는 부 버전을 올린다.
  - 수 (Patch) : 기존 버전과 호환되면서 버그를 수정한 것이라면 수 버전을 올린다.
- npm 의 버전
  - react@16.0.0 : 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존한다.
  - react@^16.0.0 : 16.0.0과 호환되는 버전을 의미한다. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정하에 상위 버전을 설치할 수 있다는 것을 의미한다. (16.0.0 ≤ 버전 < 17.0.0)
  - react@~16.0.0 : 패치 버전에 대해서만 호환되는 버전을 의미한다. (16.0.0 ≤ 버전 < 16.1.0)

### 의존성

- dependencies : `npm install 패키지명`을 실행하면 dependencies에 추가된다. 해당 프로젝트를 실행하는데 꼭 필요한 패키지가 여기에 선언된다.
- devDependencies : package.json에서 `npm install 패키지명 --save-dev`를 실행하면 devDependencies에 추가된다. 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 필요한 패키지들을 여기에 선언한다.
- peerDependencies : 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위다. 패키지를 require하거나 import하지는 않지만 호환성으로 인해 필요한 경우를 의미한다.

  - 예시)

  ```tsx
  {
  	"peerDependencies": {
  		"react": ">=16.8",
  		"react-dom": ">=16.8"
  	}
  }
  ```

- 의존성 관련 이슈를 방지하는 가장 좋은 방법은 의존성을 최소한으로 유지하는 것이다.
  - 바깥에 노출되는 면적이 클수록 위협에 노출되는 확률이 커지는 것과 마찬가지로 의존성, 즉 dependencies와 node_modules의 크기가 커질수록 위협에 노출될 확률 또한 높아진다.
  - 의존성을 최소화할 수 없다면, 내재화할 수 있는 모듈이 많지 않다면 가능한 한 널리 알려져 있고 많은 사람들이 사용하는 그리고 활발하게 유지보수되는 패키지를 사용해야 한다. 유지보수하는 주체가 없으면 점차 의존성 문제에 당면할 가능성이 크다.

# 10. 리액트 17과 18의 변경사항 살펴보기

## 리액트 17 버전 살펴보기

- 리액트 17 버전 부터는 점진적인 업그레이드가 가능하다.
    - 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 복잡성이 증가한다.
    - 점진적인 업그레이드를 채택하기 위해서라도 반드시 리액트 버전 17까지는 업그레이드 할 필요가 있다.
- 이벤트 위임 방식 변경
    - 사전지식
        - 캡처(capture) : 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타겟 타겟 요소까지 내려가는 것을 의미한다.
        - 타겟(target): 이벤트 핸들러가 타겟 노드하는 단계. 이 단계에서 이벤트가 호출된다.
        - 버블링(bubbling) : 이벤트가 발생한 요소에서 부터 시작해 최상단 요소까지 다시 올라간다.
    - 리액트의 이벤트 처리방식
        - 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. (이벤트 위임)
        - 이벤트 위임을 통해 ul의 자식에 li가 추가 또는 삭제되더라도 이벤트 핸들러도 똑같이 추가 수정할 필요도 없고, 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있다.
        - 리액트 17부터는 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리(루트) 요소로 바뀌었다. (점진적 업그레이드 지원, 바닐라 JS, jQuery 등이 혼재 돼 있는 경우 혼란 방지)
- 새로운 JSX transform
    - 16 버전 까지는 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라고 `import React from 'react'`가 필요했다.
    - 17 버전 부터 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있게 됐다.
- 이벤트 풀링 제거
    - 리액트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 객체다.
    - 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했고, 메모리 할당 작업이 일어나야 했고, 메모리 누수 방지를 위해 주기적으로 해제해야 했다.
- useEffect 클린업 함수의 비동기 실행
    - 16 버전 까지는 useEffect에 있는 클린업 함수를 동기적으로 처리했다.
    - 17 버전 부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다. - 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다. (커밋 타임이 조금이나마 빨라진다.)

## 리액트 18버전 살펴보기

- 새로 추가된 훅
    - `useId` - 컴포넌트 별로 유니크한 값을 생성
        - 서버 사이드 렌더링 환경에서 id는 서버와 클라이언트에서 동일한 값을 가져야 한다.
        - `useId` 를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부에 고유한 값을 생성할 수 있다.
    - `useTransition` - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
        - 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.
        - startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다. 경우에 따라서 여러 개의 setter를 넣어줄 수도 있다.
        - 리액트 18의 변경 사항의 핵심 중 하나인 ‘동시성(concurrency)’를 다룰 수 있는 새로운 훅이다.
        - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.
    - `useDeferredValue` - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
        - 디바운스와 비슷하지만, 디바운스는 고정된 지연시간이 필요하지만 useDefferedValue는 첫 번째 렌더링이 완료된 이후에 지연된 렌더링을 수행 한다.
        - useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하지만, useDeferredValue는 state 값 자체만을 감싸서 사용한다. (사용하는 방법만 다를 뿐 동일한 역할을 한다.)
        - props와 같이 상태 업데이트에 관여할 수 없는 경우 useDeferredValue를 사용하는 것이 타당하다.
    - `useSyncExternalStore` - 데이터의 불일치가 일어나는 tearing 현상을 해결한다.
        - 리액트가 관리할 수 없는 리액트 클로저 밖에있는 document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부상태관리 라이브러리등에 영향을 받을 때 useTransition이나 useDefferedValue 같이 ‘양보’하는 일이 일어나는 경우 데이터 불일치를 방지한다.
    - `useInsertionEffect` -
        - 기본 구조는 useEffect와 동일하지만, 실행 시점이 DOM이 실제로 변경되기 전에 동기적으로 실행된다. - 브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 되게 한다.
        - 실행 순서
            
            ```jsx
            useEffect(() => {}) // 3
            useLayoutEffect(() => {}) // 2
            useInsertionEffect(() => {}) // 1
            ```
            

### react-dom/client

- createRoot - react-dom의 `render` 를 대체할 새로운 메서드
- hydrateRoot - 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드

### react-dom/server

- renderToPipeablestream - 리액트 컴포넌트를 HTML로 렌더링하는 메서드
    - 스트림을 지원하는 메서드, HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다. 서버에서 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있다.
- renderToReadableStream - 웹 스트림을 기반으로 작동한다. 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드다.

### 자동 배치(Automatic Batching)

- 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.
- 리액트 17이하의 과거 버전에서는 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만 Promise, setTimeout 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았다.
    - 동기와 비동기 배치 작업에 일관성이 없었다.
- 리액트 18 버전부터는 루트 컴포넌트를 createRoot를 이용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됐다.
- 자동 배치를 리액트 18에서 하고 싶지 않거나 기존 코드에 영향을 미치면 `flushSync`를 사용하면 된다.
    - `flushSync`는 react가 아닌 react-dom 에서 제공 된다.

### 더욱 엄격해진 엄격 모드

- 리액트의 엄격 모드
    - 엄격 모드란?
        - 리액트에서 제공하는 컴포넌트 중 하나로, 잠재적인 버그를 찾는 데 도움이 된다.
        - 엄격 모드에서 수행하는 모드는 개발자 모드에서만 작동한다.
    - 기능
        - 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
        - 문자열 ref 사용 금지
            - 문자열로 값을 주면 여러 컴포넌트에서 사용할 수 있어서 충돌의 여지가 있다.
            - 단순한 문자열로 어떤 ref에서 참조되고 있는지 파악하기 어렵다.
            - 리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref를 추적해야 하기 때문에 성능 이슈가 있다.
        - findDOMNode 에 대한 경고 출력
            - class형 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 현재는 사용하는 것이 권장되지 않는 메서드다.
            - 부모가 특정 자식만 별도로 렌더링하는 것이 가능해서 리액트가 추구하는 트리 추상화 구조를 무너뜨린다.
            - 일회성 API라는 특징 때문에 자식 컴포넌트가 특정 시점에서 다른 노드를 렌더링할 경우 변경 사항을 추적할 수 없다.
        - 구 Context API 사용시 발생하는 경고
            - childContextType와 getChildContext를 사용하는 구 리액트 Context API를 사용하면 에러를 출력 한다.
        - 예상치 못한 side-effects 를 검사한다.
            - 함수형 컴포넌트의 body, useState, useMemo, useReducer에 전달되는 함수를 검사한다.
        - 두 번씩 실행
            - 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정. 엄격 모드에서 항상 순수한 결과물을 내고 있는지 개발자에게 확인
- Suspense 기능 강화
    - Suspense는 React.lazy를 통해 지연시켜 불로온 컴포넌트를 렌더링하는 역할을 한다. 지연 컴포넌트를 로딩하기 전에 fallback을 보여주고, 지연 로딩이 완료되면 해당 컴포넌트를 보여준다.
    - 리액트 18 이전의 Suspense의 문제점
        - 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다.
        - Suspense는 서버에서 사용할 수 없었다.
    - 수정 사항
        - 컴포넌트가 실제로 화면에 노출될 때 effect가 실행된다.
        - 서버에서도 실행할 수 있게 되었다.
        - 스로틀링이 추가되었다. 중첩된 Suspense의 fallback에 있다면 자동으로 스로틀이 되어서 최대한 자연스럽게 보여준다.
- 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요
- 그 밖에 변경사항
    - 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다.  null 반환과 동일하게 처리한다.
    - renderToNodeStream이 지원이 중단되고 renderToPipeableStream을 사용하는 것이 권장된다.

## 11. Next.js 13과 리액트 18

### app 디렉터리의 등장

- Next.js 12 버전까지는 무언가 페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다.
    - 이러한 레이아웃 한계를 극복하기 위해 나온 것이 app 레이아웃이다.
- 라우팅
    - `/pages` 로 정의하던 라우팅 방식이 `/app` 디렉터리로 이동했다.
    - `layout.js` - 루트에는 단 하나의 layout을 만들어 둘 수 있다. 모든 페이지에 영향을 미치는 공통 레이아웃이다.
    - `page.js` - Next.js에서 일반적으로 다뤘던 페이지를 의미한다.
    - `error.js` - 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트다.
    - `not-found.js` - 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.
    - `loading.js` - Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낸다.
    - `route.js` - 라우팅 주소를 담당하며 파일명은 route.js로 통일되었다.
        - REST APi의 메서드명을 예약어로 선언해주면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.

### 리액트 서버 컴포넌트

- 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 같은 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
    - 서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 나머지 작업은 클라이언트인 브라우저에서 수행된다.
- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. (서버 환경이 브라우저에는 존재하지 않으므로)
- 서버 컴포넌트
    - 요청오는 순간 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다. (`useState` 사용 불가)
    - 렌더링 생명주기도 사용할 수 없다. (`useEffect` 사용 불가)
    - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰고나 window, document 등에 접근할 수 없다.
    - 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 `async/awiat` 으로 접근할 수 있다. (컴포넌트 자체가 async한 것이 가능하다.)
    - 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나, 혹은 클라이언트 컴포넌트를 렌더링할 수 있다.
- 클라이언트 컴포넌트
    - 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
    - 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.
    - 이 두 가지 예외 사항을 제외하면 리액트 컴포넌트와 같다.
- 공용 컴포넌트
    - 서버와 클라이언트 모두에서 사용할 수 있다. 공통으로 사용할 수 있는 만큼, 서버/클라이언트 컴포넌트의 모든 제약을 받는다.

- 모든 컴포넌트는 공용 컴포넌트로 판단되고, 명시적으로 선언 하기위해 파일 맨 첫 줄에 “use client”라고 작성하면 된다.
- 서버가 렌더링을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다.
    - 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.

### Next.js에서의 리액트 서버 컴포넌트

- Next.js 13 버전 부터 서버 컴포넌트를 지원 한다.
    - `/app` 디렉터리에 서버 컴포넌트가 구현돼 있다.
    - 루트 컴포넌트는 무조건 서버 컴포넌트가 된다.
- fetch API를 확장해 같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면, 재요 청이 발생하지 않도록 요청 중복을 방지했다.

- 정적 렌더링과 동적 렌더링
    - 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게 되었다.
    - 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.

- 스트리밍을 활용한 점진적인 페이지 불러오기
    - 스트리밍을 활용하면 모든 데이터가 로드될 때까지 기다리지 않더라도 먼저 데이터가 만료되는 컴포넌트를 빠르게 보여줄 수 있다.

### 서버 액션

- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다.
- 서버 액션을 만들려면 함수 내부 또는 파일 상단에 “use server” 지시자를 선언해야 한다. (파일 내부의 모든 내용이 서버 액션으로 간주된다.)
    - 함수는 반드시 async 여야 한다.

### form의 action

- 미리 빌드되어 있는 내용 중 `ACTION_ID`를 통해 실행해야 할 내용을 찾고 서버에서 직접 실행한다.
- ‘use server’로 선언돼 있는 내용을 빌드 시점에 미리 클라이언트에서 분리시키고 서버로 옮김으로써 클라이언트 번들링 결과물에는 포함되지 않고 서버에서만 실행되는 서버 액션을 만든다.

### startTransition과의 연동

- `useTransition`이 반환하는 배열의 두 번째 요소인 `startTransition`을 사용해 서버 액션을 실행할 수 있다.
- 이전과 동일한 로직을 구현하면서도 페이지 단위의 로딩을 하지 않아도 된다.


# 12. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표
## 웹사이트와 성능

- 웹 사이트의 공통적인 사용자 기대 사항
    - 웹 사이트를 방문한 목적을 손쉽게 달성해야 함
    - 첫 번째 목적을 달성하는데 걸리는 시간이 짧아야 한다.
    - 웹 사이트에서 개인정보가 누출되는 등의 사고 없이 보안이 철저해야 한다.

### 핵심 웹 지표란?

- 핵심 웹 지표 (core web vital) 란 구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어다.
    - 핵심 웹 지표
        - LCP, FID, CLS
    - 특정 문제 진단
        - TTFB, FCP
- LCP(최대 콘텐츠풀 페인트) - 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는데 걸리는 시간
    - 개선 방향
        - 최대 콘텐츠풀 페인트 예상 영역까지 페인트 시간이 빠른 텍스트로 채우기
        - 이미지 무손실 압축
- FID(최초 입력 지연) -  웹의 반응성을 측정하는 지표
    - 개선 방향
        - 실행에 오래 걸리는 긴 작업을 분리 - Suspense와 lazy 사용. Next.js의 dynamic 이용
        - 자바스크립트 코드 최소화
- CLS(누적 레이아웃 이동) - 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표 (사용자 인터렉션에 의한 레이아웃 이동은 포함 X)
    - 개선 방향
        - 삽입이 예상되는 요소를 위한 추가적인 공간 확보 (useLayoutEffect Hook 사용 - 동기적으로 발생해 레이아웃 이동을 막으려다가 다른 모든 작업에 악 영향을 끼칠 수도 있음)
        - 폰트 로딩 최적화 - 폰트도 레이아웃 이동을 일으킴
            - linkd의 preload 사용
            - font-family의 옵션을 사용해서 우선순위에 밀어 넣고, 빠르게 로딩에 실패했으면 기본 폰트를 보여준다.
        - 적절한 이미지 크기 설정
            - 반응형 이미지를 사용하고 싶으면 srcset 속성을 사용한다.

# 13. 웹페이지의 성능을 측정하는 다양한 방법
- XSS(Cross Site Scriptiong) : 개발자가 아닌 제 3자가 삽입한 스크립트를 통해 공격하는 기법을 말한다.
    - CSP(Content Security Policy) : 웹 사이트에서 호출할 수 있는 컨텐츠를 제한하는 정책을 말한다.
- 검색 엔진 최적화
    - 검색엔진이 쉽게 웹페이지 정보를 가져가서 공개할 수 있도록 최적화돼 있는지를 확인하는 것.
    - 검색엔진 최적화가 되어 있을수록 검색 엔진의 검색결과 우선순위가 높게 나타 난다.
- 여러 연구 결과가 증명하듯 단순히 성능을 0.1초 개선한 것만으로도 사용자에게는 긍정적인 사용자 경험을 안겨줄 수 있다는 사실을 상기해야 한다.
- 프레임워크나 라이브러리의 트렌드는 변하지만 HTML과 자바스크립트, 그리고 CSS를 기본으로 한다는 것은 변함이 없다.

# 14. 웹사이트 보안을 위한 리액트와 웹페이지 보안 이슈 
- 프론트엔드에서 해야 할  일이 많아질수록 프런트엔드 코드의 규모 역시 증가하며, 코드의 규모가 증가한다는 것은 필연적으로 보안 취약점에 노출될 확률도 증가한다는 것을 의미한다.

### 리액트에서 발생하는 크로스 사이트 스크립팅(XSS)

- XSS는 웹 애플리케이션에서 가장 많이 보이는 취약점 중 하나다.
    - 웹사이트 개발자가 아닌 제3자가 웹사이트에 악성 스크립트를 삽입해 실행할 수 있는 취약점을 의미한다.
- 예시) 개시판에 사용자가 코드로 글을 올리는 경우

```jsx
<p>사용자가 글을 작성했습니다.</p>
<script>
	alert('XSS')
</script>
```

- dangerouslySetInnerHTML prop
    - dangerouslySetInnerHTML은 이름에서 알 수 있듯이 특정 브라우저 DOM의 innerHTML을  특정 내용으로 교체할 수 있는 방법이다.
    - 오직 __html을 키로 가지고 있는 객체만 인수로 받을 수 있으며, 이 인수로 넘겨받은 문자열을 DOM에 그대로 표시하는 역할을 한다. 인수로 받는 문자열에는 제한이 없다.
- useRef를 활용한 직접 삽입
    - useRef는 DOM에 직접 내용을 삽입할 수 있다.
- 리액트에서 XSS 문제를 피하는 방법
    - 제 3자가 삽입할 수 있는 HTML을 안전한 HTML 코드로 한 번 치환하는 것이다. (새니타이즈 or 이스케이프)
- 리액트의 JSX 데이터 바인딩
    - 기본적으로 리액트는 XSS를 방어하기 위해 이스케이프 작업이 존재한다.

### getServerSideProps와 서버 컴포넌트를 주의하자

- getServerSideProps가 반환하는 props 값은 모두 사용자의 HTML에 기록되고, 또한 전역 변수로 등록되어 스크립트로 충분히 접근할 수 있는 보안 위협에 노출되는 값이 된다.
    - cookie를 반환하는게 아니라 클라이언트에서 필요한 token 값만 제한적으로 반환하는 등 불필요한 노출을 줄여야 한다.

### <a> 태그의 값에 적절한 제한을 둬야 한다.

```jsx
<a href="javascript:'" onClick={handleClick}>
	링크
</a>
```

- href에 ‘javascript:’ 로 시작하는 자바스크립트 코드를 넣어두면 href로 선언된 URL로 페이지를 이동하는 것을 막고 onClick이 이벤트와 같이 별도 이벤트로 핸들러만 작동시키기 위한 용도로 사용된다.
    - 이는 안티페턴이다.
    - ‘href’가 작동하지 않는것이 아니라 ‘javascript:;’만 실행 되는 것이다. ‘href’ 내에 자바스크립트 코드가 존재한다면 이를 실행한다.

### HTTP 보안 헤더 설정하기

- HTTP 보안 헤더란 브라우저가 렌더링하는 내용과 관련된 보안 취약점을 미연에 방지하기 위해 브라우저와 함께 작동하는 헤더를 의미한다.
- Strict-Transport-Security
    - 모든 사이트가 HTTPS를 통해 접근해야 하며, 만약 HTTP로 접근하는 경우 이러한 시도는 HTTPS로 변경되게 한다.
    - 사용법 : `Strict-Transport-Security: max-age=<expire-time>; includeSubDomains`
    - <expire-time>은 이 설정을 브라우저가 기억해야 하는 시간을 의미한다.  권장값은 2년이다.
- X-XSS-Protection
    - 비표준 기술로 사파리와 구형 브라우저에서만 제공된다.
    - XSS 취약점이 발견되면 페이지 로딩을 중단한다.
- X-Frame-Options
    - frame, iframe, embed, object 내부에서 렌더링을 허용할지를 나타낼 수 있다.
    - 제 3의 페이지에서 <iframe>으로 삽입되는 것을 막는다.
- Permissions-Policy
    - 웹사이트에서 사용할 수 있는 기능과 사용할 수 없는 기능을 명시적으로 선언하는 헤더다.
- X-Content-Type-Options
    - 먼저 MIME이 무엇인지 알아야한다.
        - 원래는 메일을 전송할 때 사용하던 인코딩 방식으로, 현재는 Content-type에서 대표적으로 사용된다.
    - X-Content-Type-Options란 Content-type 헤더에서 제공하는 MIME 유형이 브라우저에 의해 임의로 변경되지 않게 하는 헤더다.
- Referrer-Policy
    - HTTP 요청에는 Referer라는 헤더가 존재하는데, 이 헤더에는 현재 요청을 보낸 페이지의 주소가 나타난다.
    - 주소의 출처는 다음과 같이 구성된다. - 예시) https://yceffort.kr
        - scheme : HTTPS 프로토콜을 의미한다.
        - hostname : yceffort.kr라는 호스트 명을 의미한다.
        - port : 443 포트를 의미한다.
    - 이 scheme, hostname, port의 조합을 출처라고 한다.

### 취약점이 있는 패키지의 사용을 피하자

- npm 프로젝트 구동을 위해서는 수많은 패키지에 의존해야하는데 의존해야 하는 패키지의 목록은 기본적으로 package.json의 dependencies와 devDependencies에 나열돼 있고, package-lock.json에는 이 package.json이 의존하는 또 다른 패키지들이 명시돼 있다
- package-lock.json에 모든 의존성을 파악하는 것은 사실상 불가능에 가깝다.
- Dependabot을 사용해서 취약점을 발견하는 것이 좋다.