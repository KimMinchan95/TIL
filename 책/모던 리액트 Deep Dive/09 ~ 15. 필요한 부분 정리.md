# 09 ~ 15는 지금 당장 필요하지 않은 부분들이 많아서 책은 다 읽되 필요한 부분만 정리할 예정

## 09.모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

### create-next-app 없이 하나씩 구축하기

- `package.json` 만들기
  - `npm init`을 실행하면 `package.json`을 만드는 CLI를 실행할 수 있다.
  - Next.js 프로젝트를 실행하는데 필요한 핵심 라이브러리인 `react`, `react-dom`, `next`를 설치한다.
  - devDependencies에 필요한 `typescript`, `@types/react`, `@types/react-dom`, `@types/node` 그리고 ESLint에 필요한 `eslint`, `eslint-config-next`를 설치한다.
- tsconfig.json 작성하기
  - 타입스크립트 설정을 기록한다.
  - JSON 파일 최상단에 `$schema` 키와 값을 넣으면 해당 JSON 파일이 무엇을 의미하는지, 어떤 키와 값이 들어갈 수 있는지 알려준다. (.eslintrc, .prettierrc 같은 JSON 방식으로 설정을 작성하는 라이브러리가 schemastore에 해당 내용을 제공하고 있다면 편리하게 JSON 설정을 작성할 수 있다.
- next.config.js 작성하기
  - Next.js 설정을 위한 next.config.js를 만든다.
  - 버전별로 설정이 조금씩 다르므로 본인이 사용하고 있는 next.config.js에서 사용 가능한 옵션을 확인하기 위해 깃허브 저장소를 방문해야 한다.
- ESLint와 Prettier 설정하기
- 스타일 설정하기
- 애플리케이션 코드 작성

- 깃 허브에서 제공하는 기본 액션
  - `action/checkout` - 깃허브 저장소를 체크아웃 하는 액션
  - `actions/setup-node` - Node.js를 설치하는 액션
    - 설치할 Node.js버전을 지정할 수도 있다.
  - `actions/github-script` - GitHub API가 제공하는 기능을 사용할 수 있도록 도와주는 액션
  - `actions/stale` - 오랜된 이슈나 PR을 자동으로 닫거나 더 이상 커뮤니케이션하지 못하도록 닫는다.
  - `actions/dependency-review-action` - 의존성 그래프에 대한 변경 등의 내용이 변경되었을 때 실행되는 액션으로, 의존성을 분석해 보안 또는 라이센스에 문제가 있다면 이를 알려준다.
  - `github/codeql-action` - 깃허브의 코드 분석 솔루션인 code-ql을 활용해 저장소 내 코드의 취약점을 분석해 준다.
- `calibreapp/image-actions`
  - pr로 올라온 이미지를 sharp패키지를 이용해 거의 무손실 압축해서 다시 커밋해 준다.
- `Lighthouse CI`
  - 구글에서 제공하는 액션으로 라이트하우스를 CI기반으로 실행할 수 있도록 도와주는 도구이다.

### package.json의 dependencies 이해하기

- 버전
  - 주 (Major) : 기존 버전과 호환되지 않게 API가 바뀌면 주 버전을 올린다.
  - 부 (Minor) : 기존 버전과 호환되면서 새로운 기능을 추가할 때는 부 버전을 올린다.
  - 수 (Patch) : 기존 버전과 호환되면서 버그를 수정한 것이라면 수 버전을 올린다.
- npm 의 버전
  - react@16.0.0 : 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존한다.
  - react@^16.0.0 : 16.0.0과 호환되는 버전을 의미한다. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정하에 상위 버전을 설치할 수 있다는 것을 의미한다. (16.0.0 ≤ 버전 < 17.0.0)
  - react@~16.0.0 : 패치 버전에 대해서만 호환되는 버전을 의미한다. (16.0.0 ≤ 버전 < 16.1.0)

### 의존성

- dependencies : `npm install 패키지명`을 실행하면 dependencies에 추가된다. 해당 프로젝트를 실행하는데 꼭 필요한 패키지가 여기에 선언된다.
- devDependencies : package.json에서 `npm install 패키지명 --save-dev`를 실행하면 devDependencies에 추가된다. 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 필요한 패키지들을 여기에 선언한다.
- peerDependencies : 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위다. 패키지를 require하거나 import하지는 않지만 호환성으로 인해 필요한 경우를 의미한다.

  - 예시)

  ```tsx
  {
  	"peerDependencies": {
  		"react": ">=16.8",
  		"react-dom": ">=16.8"
  	}
  }
  ```

- 의존성 관련 이슈를 방지하는 가장 좋은 방법은 의존성을 최소한으로 유지하는 것이다.
  - 바깥에 노출되는 면적이 클수록 위협에 노출되는 확률이 커지는 것과 마찬가지로 의존성, 즉 dependencies와 node_modules의 크기가 커질수록 위협에 노출될 확률 또한 높아진다.
  - 의존성을 최소화할 수 없다면, 내재화할 수 있는 모듈이 많지 않다면 가능한 한 널리 알려져 있고 많은 사람들이 사용하는 그리고 활발하게 유지보수되는 패키지를 사용해야 한다. 유지보수하는 주체가 없으면 점차 의존성 문제에 당면할 가능성이 크다.

# 10. 리액트 17과 18의 변경사항 살펴보기

## 리액트 17 버전 살펴보기

- 리액트 17 버전 부터는 점진적인 업그레이드가 가능하다.
    - 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 복잡성이 증가한다.
    - 점진적인 업그레이드를 채택하기 위해서라도 반드시 리액트 버전 17까지는 업그레이드 할 필요가 있다.
- 이벤트 위임 방식 변경
    - 사전지식
        - 캡처(capture) : 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타겟 타겟 요소까지 내려가는 것을 의미한다.
        - 타겟(target): 이벤트 핸들러가 타겟 노드하는 단계. 이 단계에서 이벤트가 호출된다.
        - 버블링(bubbling) : 이벤트가 발생한 요소에서 부터 시작해 최상단 요소까지 다시 올라간다.
    - 리액트의 이벤트 처리방식
        - 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. (이벤트 위임)
        - 이벤트 위임을 통해 ul의 자식에 li가 추가 또는 삭제되더라도 이벤트 핸들러도 똑같이 추가 수정할 필요도 없고, 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있다.
        - 리액트 17부터는 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리(루트) 요소로 바뀌었다. (점진적 업그레이드 지원, 바닐라 JS, jQuery 등이 혼재 돼 있는 경우 혼란 방지)
- 새로운 JSX transform
    - 16 버전 까지는 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라고 `import React from 'react'`가 필요했다.
    - 17 버전 부터 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있게 됐다.
- 이벤트 풀링 제거
    - 리액트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 객체다.
    - 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했고, 메모리 할당 작업이 일어나야 했고, 메모리 누수 방지를 위해 주기적으로 해제해야 했다.
- useEffect 클린업 함수의 비동기 실행
    - 16 버전 까지는 useEffect에 있는 클린업 함수를 동기적으로 처리했다.
    - 17 버전 부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다. - 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다. (커밋 타임이 조금이나마 빨라진다.)

## 리액트 18버전 살펴보기

- 새로 추가된 훅
    - `useId` - 컴포넌트 별로 유니크한 값을 생성
        - 서버 사이드 렌더링 환경에서 id는 서버와 클라이언트에서 동일한 값을 가져야 한다.
        - `useId` 를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부에 고유한 값을 생성할 수 있다.
    - `useTransition` - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
        - 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.
        - startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다. 경우에 따라서 여러 개의 setter를 넣어줄 수도 있다.
        - 리액트 18의 변경 사항의 핵심 중 하나인 ‘동시성(concurrency)’를 다룰 수 있는 새로운 훅이다.
        - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.
    - `useDeferredValue` - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
        - 디바운스와 비슷하지만, 디바운스는 고정된 지연시간이 필요하지만 useDefferedValue는 첫 번째 렌더링이 완료된 이후에 지연된 렌더링을 수행 한다.
        - useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하지만, useDeferredValue는 state 값 자체만을 감싸서 사용한다. (사용하는 방법만 다를 뿐 동일한 역할을 한다.)
        - props와 같이 상태 업데이트에 관여할 수 없는 경우 useDeferredValue를 사용하는 것이 타당하다.
    - `useSyncExternalStore` - 데이터의 불일치가 일어나는 tearing 현상을 해결한다.
        - 리액트가 관리할 수 없는 리액트 클로저 밖에있는 document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부상태관리 라이브러리등에 영향을 받을 때 useTransition이나 useDefferedValue 같이 ‘양보’하는 일이 일어나는 경우 데이터 불일치를 방지한다.
    - `useInsertionEffect` -
        - 기본 구조는 useEffect와 동일하지만, 실행 시점이 DOM이 실제로 변경되기 전에 동기적으로 실행된다. - 브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 되게 한다.
        - 실행 순서
            
            ```jsx
            useEffect(() => {}) // 3
            useLayoutEffect(() => {}) // 2
            useInsertionEffect(() => {}) // 1
            ```