### JSX

- JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.
  - JSX가 주로 사용되는 곳은 리액트 내부에서 반환하는 HTML과 자바스크립트 코드이지만, 그것에 한정돼 있는 것이 아니다. HTML, XML 외에도 다른 구문으로도 확장될 수 있게끔 고려돼 있다.

> JSX는 **XML 문법을 차용한 JavaScript** 이다.

- HTML 말고 XML 스타일을 쓰는 이유는 정확하고 엄격한 문법이 필요하기 때문이다. (모든 태그를 닫아야 하고, 중첩이 정확해야 한다.)
- JSX는 코드를 선언적으로 표현할 수 있다. (HTML DOM 조작을 직접 하는 명령형 방식에 비해 알아보기 쉽다.)

  >

- `JSXElement` 만 다르고, `JSXAttributes`, `JSXChildren`이 완전히 동일한 상황에서 중복을 최소화 할 수 있는 예제

```tsx
import { createElement, PropsWithChildren } from 'react';

// X - 코드 중복 예시
function TextOrHeading({
	isHeading,
	children,
}) {
	return isHeading ? (
		<h1 className="text">{children}</h1>
	) : (
		<span className="text">{children}</span>
	)
}

// O - JSX가 반환되는 특성을 활용한 예시
function TextOrHeading ({
	isHeading,
	children,
} {
	return createElement(
		isHeading ? 'h1' : 'span',
		{ classname: 'text' },
		children
	)
}
```

## 가상 DOM과 리액트 파이버

- **DOM과 브라우저 렌더링 과정**

  1. 브라우저는 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
  2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(**DOM**)를 만든다.
  3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드 한다.
  4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(**CSSOM**)를 만든다.
  5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 **눈에 보이는 노드**만 방문한다. (head, display: none 요소는 제외하는 등, 이는 트리를 분석하는 과정을 빠르게 하기 위해)
  6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. DOM 노드에 CSS를 적용하는 과정은 크게 두 가지 이다.
     1. 리플로우(reflow, layout) : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. **이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.**
     2. 페인팅(painting) : 레이아웃 단계를 거친 노드에 색과 같이 실제 유효한 모습을 그리는 과정.

- 가상 DOM 탄생 배경

  - 렌더링 이후 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 SPA에서 더욱 많아진다.
  - HTML을 새로 받아서 다시금 렌더링 과정을 시작하는 일반적인 웹페이지와는 다르게 하나의 페이지에서 계속해서 요소의 위치를 재계산하게 된다. 라우팅이 변경되는 경우 사이드바나 헤더 같은 특정 요소를 제외하면 삭제, 삽입, 위치 계산등의 작업을 수행해야 한다.

- 가상 DOM은 일반 DOM을 관리하는 것 보다 무조건 빠를까?
  - 리액트의 개발자인 댄 아브라모프(dan_abramov)가 사실이 아니라고 부정한 바가 있다.
  - 작은 규모의 프로젝트나, 복잡한 컴포넌트 트리(diff 알고리즘이 오래걸림), React 최적화 도구(memo 등)을 사용하지 않아서 렌더링 제어가 부족할때.

### 리액트 파이버란?

- 리액트에서 관리하는 평범한 자바스크립트 객체다. 파이버 재조정자(fiber reconciler)가 관리한다.

  - 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 화면에 렌더링을 요청하는 역할을 한다.

- 리액트 파이버의 목표는 리액트 웹앱에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다.

  - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
  - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
  - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

- 파이버는 모든 과정을 **비동기**로 처리한다.

  - 과거 리액트에는 조정 알고리즘이 스택 알고리즘으로 이뤄져 있어서 모든 스택을 비울 때 까지 작업을 한번에 처리했다. JS는 싱글 스레드라는 점으로 인해 중단될 수 없었다.
  - React 16에서 도입된 Fiber로 **작업을 쪼개**서 중단하고, 다시 이어 붙일 수 있게 되었다.

- 파이버의 구현

  - 파이버는 **하나의 작업 단위**로 구성돼 있다. 이러한 작업 단위를 하나씩 처리하고 `finishedWork()` 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.
    - **렌더 단계** : 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
    - **커밋 단계**(Commit Phase): 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

- 커밋 단계를 거치고 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다.
  - 클래스형 컴포넌트에서는 `componentDidMount`, `componentDidUpdate` 메서드를 호출한다.
  - 함수형 컴포넌트에서는 `useLayoutEffect` 훅을 호출한다.

- Value UI
  - 리액트 개발 팀은 사실 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바 있다.
  - 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다.
  - 변수에 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.

### 리액트 파이버 트리

- 리액트 파이버는 더블 버퍼링을 사용한다. - 커밋 단계에서 수행

  - 하나는 **현재 모습(current)**을 담은 파이버 트리이고, 하나는 **작업 중인 상태(workInProgress)**를 나타내는 트리이다.
  - 화면에 미처 다 그리지 못한 모습을 보여주지 않기 위한 장치이다.

- 파이버의 작업 순서

  1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행한다. 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
  2. 1번에서 작업이 끝난다면 그다음 `completeWork()` 함수를 실행해 파이버 작업을 완료한다.
  3. 형제가 있다면 형제로 넘어간다.
  4. 2번, 3번이 모두 끝났으면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

- 리액트 파이버와 가상DOM

  - 가상 DOM은 UI의 상태를 내는 **데이터 구조**
  - 파이버는 이 가상 DOM을 **어떻게** 계산하고 처리할지를 정의한 **내부 구현 구조**

- **파이버는 가상 DOM을 조작하고, 그것을 실제 DOM으로 변환하는 과정 전체를 관리한다.**
  - 파이버는 가상 DOM을 기반으로 새로운 파이버 트리를 만들고, 기존 트리와 비교해서 어떤 변경이 필요한지 계산한다.
  - 그 후, Commit Phase에서 실제 DOM을 업데이트 한다.

## 클래스형 컴포넌트와 함수형 컴포넌트

- 함수형 컴포넌트는 리액트 0.14 버전부터 만들어진 컴포넌트 선언 방식이다.
  - 이때는 stateless functional components, 무상태 함수형 컴포넌트라고 해서 별도의 상태 없이 단순히 어떠한 요소를 정적으로 렌더링하는 것이 목적이었다.
  - 함수형 컴포넌트가 각광받기 시작한 것은 16.8 버전에서 훅이 소개된 이후이다.

### 클래스형 컴포넌트

- 클래스형 컴포넌트 - 생명주기 메서드가 실행되는 시점

  - 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
  - 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
  - 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

- 클래스형 컴포넌트의 한계
  - 데이터 흐름을 추적하기 어렵다
    - 여러 메서드에서 state의 업데이트가 일어날 수 있다.
  - 애플리케이션 내부 로직의 재사용이 어렵다.
    - 공통 로직이 많아질수록 이를 감싸는 고차컴포넌트 내지는 props가 많아진다.
    - 컴포넌트를 상속해서 중복코드를 관리할 수도 있지만, 상속되고 있는 클래스와 흐름을 쫓아가야한다.
    - 기능이 많아질수록 컴포넌트의 크기가 커진다.
      - 내부에서 처리하는 데이터 흐름이 복잡해져 생명주기 메서드 사용이 잦아지는 경우 컴포넌트 크기가 기하급수적으로 커진다.
    - 코드 최적화하기 어렵다.
      - 함수의 이름이 최소화(minified)되지 않는다.
      - 사용하지 않는 메서드가 트리쉐이킹 되지않는다.

### 함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기 메서드의 부재
  - `useEffect` 훅을 사용해서 생명주기 메서드인 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`를 비슷하게 구현할 수 있다.
    - `useEffect`는 생명주기를 위한 훅이 아니라 `state` 를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.
- 함수형 컴포넌트와 렌더링된 값
  - 3초뒤에 props에 있는 state를 띄워주는 `alert`을 `handleClick` 로 함수형과 클래스형 컴포넌트에서 구현하면 차이가 있다.
  - 클래스형 컴포넌트는 3초 뒤에 변경된 props를 기준으로 메시지가 뜨고 함수형 컴포넌트는 클랙했던 시점의 props 값을 기준으로 메시지가 뜬다.
    - 클래스형 컴포넌트는 props를 항상 `this`로 부터 가져온다. props는 외부에서 변경되지 않는 이상 불변 값이지만 `this`가 가르키는 객체는 mutable한 값이다.
    - 함수형 컴포넌트는 props로 인수를 받기 때문에 컴포넌트는 그 값을 변경할 수 없고, 해당 값을 그대로 사용하게 된다.

## 렌더링은 어떻게 일어나는가?

- 브라우저에서의 렌더링
  - HTML, CSS, JS로부터 실제 화면을 그리는 과정
- **리액트에서의 렌더링**
  - 컴포넌트 함수가 실행되어 JSX를 반환하고, 리액트가 가상 DOM을 생성/업데이트하는 과정
  - 실제 브라우저 화면을 건드리는 건 아님(Commit Phase가 실행되어야됨)

### 리액트의 렌더링이 일어나는 경우

1. 최초 렌더링 : 브라우저에 정보를 제공하기 위해
2. 리렌더링 : 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링 - 아래 방식들이 유일하다.
   1. 클래스형 컴포넌트의 setState가 실행되는 경우
   2. 클래스형 컴포넌트의 foreUpdate가 실행되는 경우
   3. 함수형 컴포넌트의 useState의 두 번째 배열 요소인 setter가 실행되는 경우
   4. 함수형 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
   5. 컴포넌트의 key props가 변경되는 경우 - 파이버가 current트리와 workInProgress 트리 사이에 구별하는 값
   6. props가 변경되는 경우
   7. 부모 컴포넌트가 렌더링될 경우

### 리액트의 렌더링 프로세스

렌더링 중 재조정(Reconciliation) 과정

- 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
- 업데이트가 필요하다고 지정되어있는 경우
  - 클래스형 컴포넌트의 경우 클래스 내부의 `render()` 함수를 실행한다.
  - 함수형 컴포넌트인 경우 `FunctionComponent()` 그 자체를 호출한 뒤에, 결과를 저장한다.
- 일반적으로 렌더링 경과물은 JSX 문법으로 구성되어 있고, 자바스크립트로 컴파일되면서 `React.createElement()` 를 호출하는 구문으로 변환된다.

```tsx
function Hello() {
	return (
		<TestComponent a={35} b="yceffort">
			안녕하세요
		</TestComponent>
	)
}

// React.createElement 호출
function Hello() {
	return React.createElement(
		TestComponent,
		{ a: 35, b: 'yceffort' },
		'안녕하세요',
	)
}

// 결과물
{type: TestComponent, props: {a: 35, b: "yceffort", children: "안녕하세요"}}
```
### 렌더와 커밋

- **렌더 단계**(Render Phase) : 컴포넌트를 리렌더링하고 변경 사항을 계산하는 모든 작업
  - 렌더링 프로세스에서 컴포넌트를 실행해(`render()` 또는 `return`) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요(type, props, key가 변한) 컴포넌트를 체크하는 단계
- **커밋 단계**(Commit Phase) \*\*\*\*: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

- 커밋 단계를 거치고 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다.
  - 클래스형 컴포넌트에서는 `componentDidMount`, `componentDidUpdate` 메서드를 호출한다.
  - 함수형 컴포넌트에서는 `useLayoutEffect` 훅을 호출한다**.**
- **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.**
  - 변경 사항이 감지되지 않았으면 커밋 단계는 생략될 수 있다.
  - 즉 리액트의 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다.
