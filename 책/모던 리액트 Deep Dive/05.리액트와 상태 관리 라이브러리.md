## 상태 관리는 왜 필요한가?

- 상태는 웹 앱을 개발할 때 - 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값이다.
  - UI : 상호 작용이 가능한 모든 요소의 현재 값
    - 다크/라이트 모드
    - 라디오를 비롯한 각종 input
    - 알림창의 노출 여부
  - URL : 브라우저에서 관리되고 있는 상태값
    - `https://www.aribnb.co.kr/rooms/34113796?adults=2` 에서 `roomId=34113796` 과 `adults=2` 라고 하는 상태가 존재하며 사용자의 라우팅에 따라 변경된다.
  - 폼 (form)
    - 로딩 중인지, 현재 제출됐는지, 접근이 불가능한지, 값이 유효한지 등
  - 서버에서 가져온 값
    - 클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다.

### 리액트 상태 관리의 역사

- Flux 패턴
  - 웹 앱이 비대해지고 상태도 많아짐에 따라 이 상태가 변했는지 등을 추적하고 이해하기 어려운 상황이었다.
  - 페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인딩으로 보고 단방향으로 데이터 흐름을 변경하는 것을 제안했다. 이것이 바로 Flux 패턴의 시작이다.
- Flux의 단방향 흐름 **Action → Dispatcher → Model → View**
  - **액션(Action)** : 어떠한 작업을 처리할 액션과 그 액션 발생시 함께 포함시킬 데이터를 의미. 액션 타입과 데이터를 정의에 디스패처로 보낸다.
  - **디스패처(Dispatcher)** : 액션을 스토어에 보내는 역할. 콜백 함수 형태. 앞서 정의한 타입과 데이터를 스토어에 보낸다.
  - **스토어(Store)** : 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드. 액션의 타입에 따라 어떻게 변경할지가 정의돼 있다.
  - **뷰(View)** : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링 하는 역할을 한다. 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트 할 수 있다. 뷰에서 액션을 호출해서 디스패처로 보낼 수 있다.

### 리덕스 등장

- 리덕스는 최초에는 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나였다.
- 여기에 Elm 아키텍처를 도입한게 특별한 점이다.
  - Elm은 웹페이지를 선언적으로 작성하기 위한 언어다. - model, view, update 구조
- 보일러 플레이트 코드 문제로 많은 비판을 받았고, 현재는 작업이 간소화 되었다.

### Context API와 useContext

- 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 추가했다.
- 이전에는 `getChildContext`가 있었는데 렌더링 문제와 결합도가 높아지는 단점이 있었다.
- Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않는다.

### 훅의 탄생, 그리고 React Query와 SWR

- 두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리다.
- 다른 곳에서 동일한 키로 호출하면 재조회하는 것이 아니라 `useSWR`이 관리하고 있는 캐시의 값을 활용한다.

### Recoil, Zustnad, Jotai, Valtio

- SWR과 React Query보다 범용적으로 사용할 수 있는 상태 관리 라이브러리 들이다.
- 기존의 리덕스 같은 라이브러리와는 차이점이 있는데 훅을 활용해서 작은 크기의 상태를 효율적으로 관리한다.

## 리액트 훅으로 시작하는 상태 관리

### 가장 기본적인 방법 : useStaet와 useReducer

- `useState`와 `useReducer`는 지역 상태를 관리하는 훅이다.
  - 지역 상태는 컴포넌트 내에서만 유효하다.
  - 서로가 서로를 사용해서 구현할 수 있다. - 구현상 차이만 있을 뿐, 두 훅 모두 지역 상태 관리를 위해서 만들어졌다.
- 커스텀 훅을 사용해서 상태를 관리하는 코드를 격리해 제공할 수 있다.
  - 훅을 사용할 때마다 컴포넌트별로 초기화되어서 다른 상태를 가질 수밖에 없다.
- 지역상태에서 벗어날려면 Parent라고 하는 상위 컴포넌트에서 훅을 호출해서 반환값을 하위 컴포넌트의 props로 전달해야 한다.

### useState의 상태를 바깥으로 분리하기

- `useState`는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되기 때문에 해당 컴포넌트 안에서만 사용할 수 있다.
  - 리액트 클로저가 아닌 다른 자바스크립트 실행 문맥에서 초기화돼서 관리되면, 유효한 스코프 내부에서 해당 객체의 값을 공유해서 사용할 수 있을 것이다.
- 외부에서 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어 날려면 다음과 같은 조건을 만족해야한다.
  - `window`나 `global`에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
  - 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트, 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
  - 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다.

## 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

- Recoil과 Jotai는 Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞춘다.
- Zustnad는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리다. (수정 : 스토어를 여러개 만들 수 있음)
  - Recoil, Jotai와 다르게 Context가 아닌 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알린다.

### Recoil

- 최초 상태 개념인 Atom을 처음 리액트 생태계에 선보였다.
- `RecoilRoot`
  - Recoil을 사용하기 위해서 `RecoilRoot`를 애플리케이션 최상단에 선언해야 한다.
  - Recoil의 상태 값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
  - 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
  - 값이 변경이 발생하면 이를 참조하고 있는 하위컴포넌트에 모두 알린다.
- `atom`
  - `atom`은 상태를 나타내는 Recoil의 최소 상태 단위다.
  - `atom`은 `key` 값을 필수로 가지며, 식별자가 되는 필수 값이다. - 애플리케이션 내부에서 유일한 값이어야 한다.
- `useRecoilValue`
  - `atom`의 값을 읽어오는 훅이다.
- `useRecoilState`
  - `useRecoilValue` 가 단순히 `atom`의 값을 가져오기 위한 훅이었다면 `useRecoilState`는 좀 더 `useState`와 유사한 값을 가져오고, 이 값을 변경할 수도 있는 훅이다.
- 특징
  - `selector`를 필두로 다양한 비동기 작업을 지원하는 API를 제공한다.
  - Recoil에서도 자체적인 개발 도구를 지원한다.

### Jotai

- Jotai는 Recoil의 atom 모델에서 영감을 받아 만들어진 상태 관리 라이브러디ㅏ.
- Jotai는 상향식(bottom-up) 접근법을 취하고 있는다.
  - 리덕스처럼 하나의 큰 상태를 애플리케이션에 내려주(top-down)는 방식이 아니라, 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있음을 의미한다.
- `atom`
  - Recoil과 마찬가지로 최소 단위의 상태를 의미한다.
  - `atom`을 생성할 때마다 고유한 key를 필요로 했던 Recoil과 다르게, Jotai는 생성할 때 별도의 key를 넘겨주지 않아도 된다.
  - `useState`와 다르게 컴포넌트 외부에서도 선언할 수 있다.
- `useAtomValue`
  - `atom`에 따로 상태를 저장하지 않고 `useAtomValue` 에 저장한다.
  - Recoil과 다르게, 컴포넌트 루트 레벨에서 Context가 존재하지 않아도 된다.
    - Context가 없다면 Provider가 없는 형태로 기본 스토어를 루트에 생성하고 이를 활용해 값을 저장한다.
    - Jotai에서 export하는 Provider를 사용하면 Provider 별로 atom값을 관리할 수도 있다.
- `useAtom`
  - `useState`와 동일한 형태의 배열을 반환한다.
    - 첫 번째로는 `atom`의 현재 값을 나타내는 `useAtomValue`훅의 결과를 반환한다.
    - 두 번째로는 `useSetAtom` 훅을 반환한다.

## Zustand

- Zustand는 리덕스에 영감을 받아 만들어졌다.
- 순수 자바스크립트 환경에서도 사용할 수 있다.
- `createStore`로 스토어를 만들 때 `set`이라는 인수를 활용해 스토어의 값을 재정의할 수도 있고, 두 번째 인수로 get을 추가해 현재 스토어의 값을 받아올 수도 있다.
- `getState`와 `setState`를 통해 현재 스토어의 값을 받아오거나 재정의할 수 있다.
- `subscribe`를 통해 스토어의 값이 변경될 때마다 특정 함수를 실행할 수도 있다.
