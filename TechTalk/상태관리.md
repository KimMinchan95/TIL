# 상태관리

[[10분 테코톡] 온스타의 상태관리](https://www.youtube.com/watch?v=jqir73Lourk&list=PLkfxusmKmLsNDGmER2tmrslpPOTfKhE7j&index=128)

## 상태란?

> 유저와의 상호작용을 위한, 변할 수 있는 데이터
> 
- 눈에 보이는 “데이터”들은 전부 상태
- 눈에 보이지 않지만 기능을 작동 시키기 위해 어딘가에 숨겨져있는 데이터 (로딩상태, 좋아요 .)

## 상태관리란?

> 유저와의 상호작용을 위해, 상태를 조작하고 다루는 모든 작업
> 
- 유저에게 UI/UX 제공
- 유저와 데이터 주고 받기

### 상태관리가 중요한 이유

- 상태는 언제든지 유저의 상호 작용, 화면의 변화에 따라서 비동기적 & 지속적으로 변할 수 있다.
- 서비스가 방대해지고, 하는 역할들이 많아지면 상태가 언제, 어디서, 왜 변하는지 추적하기 힘들어 질 수 있다.

- 상태 관리에 실패한 경우
    - 불필요한 리렌더링
    - 의도하지 않은 UI/UX
    - 유지 보수하기 힘든 코드

### 과거의 상태관리

- J-Query에서는 HTML에 `data attribute` 에 있는 데이터를 받아와서 사용했다. (data-* 속성 사용)
- DOM 중심의 상태관리 로직
- 상태 변화 추적이 어려움

## SPA의 등장

- DOM에 접근없이도 데이터가 변경되면 값이 변경될 수 있도록 지원
- 데이터 중심의 상태관리 로직
    - 어디에서 상태가 변경되었는지 추적에 유리

### 리액트의 상태관리

- 단방향 데이터 흐름
- 상위컴포넌트 State ⇒ 하위 컴포넌트 Props ⇒ 하위 컴포넌트 Props
    - Prop Drilling : 상태 변화의 추적이 어려워진다.
- 상태관리의 어려움으로 인해 Redux로 상태관리 : Flux Architecture + reducer
    - 컴포넌트들의 의존성 분리
    - Redux DevTools - 상태 변화 추적 용이
    - 많은 보일러 플레이트 코드
    - API 통신 관련 코드를 전역적으로 관리

### 좋은 리액트 상태 관리란?

- 무분별한 전역 상태관리는 피하자
    - 합성 컴포넌트를 적절히 활용하여 Prop Drilling을 해소할 수 있다.
- 서버의 데이터를 전역 상태에 저장할때는 명확한 전략을 갖자.
    - 명확한 전략이 없다면, 라이브러리를 똑똑하게 활용하자.
- 상태 코드는 연관 컴포넌트들과 최대한 가까이 배치하자. (State Colocation)
    - 하나의 컴포넌트가 많은 상태를 가지고있다면, 해당 컴포넌트가 너무 많은 일을 하는 것은 아닌지 고민한다.