# 자바스크립트의 데이터 타입과 불변성

[[10분 테코톡] 소피아의 데이터타입과 불변성](https://www.youtube.com/watch?v=hM8s3ZaycGk&list=PLkfxusmKmLsNDGmER2tmrslpPOTfKhE7j&index=111&t=498s)

## 데이터 타입

- 자바스크립트에는 7가지 데이터 타입(Data type)이 존재한다.
- 크게 Object와 Object가 아닌 것으로 나눌 수 있다.
    - Object인 것 (Mutable - 가변)
        - Object
            - Array
            - Function
            - Date
            - RegExp
    - Object가 아닌 것 (Primitive type, Immutable - 불변)
        - Undefined
        - Null
        - Boolean
        - String
        - Number
        - Symbol

## 변수와 값 알아보기

- 컴퓨터는 데이터를 메모리에 저장하여 기억한다.
    - 메모리는 주소값이 있는 저장 공간이다.

**예시)**

```jsx
var a = "저장할 데이터"
```

**과정**

- 메모리의 변수영역에서 하나의 공간을 확보하고
    - 그 공간에 이름을 a로 지정한다.
- 데이터 영역에도 하나의 공간을 확보하고
    - 변수에 할당한 `“저장할 데이터”`라는 문자열을 저장한다.
- 할당한 데이터 공간의 주소값을 이름 a를 지정해준 변수공간에 값으로 저장한다.
    
    

**결론**

- 변수는 값이 저장된 데이터 공간의 주소를 가지고 있고
- 그 주소를 통해 값에 접근할 수 있다.

## Primitive type은 불변하다.

**예시)**

```jsx
var a = "저장할 데이터";
a = "새로운 데이터"
```

- 기존 변수의 새로운 문자열을 할당할 때, 데이터 공간에 저장한 `“저장할 데이터”`가 `"새로운 데이터"` 으로 바뀔까?
    - **그렇지 않다.** 데이터 공간에 저장된 값은 바꿀 수 없다.

**과정**

- 저장된 문자열 `"저장할 데이터"`는 그대로 둔다.
- 문자열 `"새로운 데이터"`를 새로운 공간에 저장한다.
- 변수가 들고 있는 값을 `"새로운 데이터"`가 저장된 주소로 바꿔준다.
- 두 문자열은 모두 메모리에 존재하고, 변수가 가르키는 공간만 바꿔주는 것이다.
- 추후에 사용하지 않는 문자열 `“저장할 데이터”`는 제거가 된다.

### 새로운 변수 할당

**예시)**

```jsx
var a = "저장할 데이터";
var b = a;
a = "새로운 데이터";
```

**과정**

- 이전과 마찬가지로 하나의 변수 공간을 확보한다.
- 그 공간의 이름을 b로 짓는다.
- a와 똑같이 b도 문자열 `“저장할 데이터”`의 주소를 값으로 갖는다.
- a에 새로운 데이터가 할당되면 a의 값만 `"새로운 데이터"`주소의 값으로 바뀐다.

## Object는 가변하다.

**예시)**

```jsx
var obj = {
	name: 'chan',
	skill: 'js',
}
```

**과정**

- 객체를 할당한 변수도 변수이기 때문에 먼저 변수 공간을 확보한다.
- 객체는 여러 개의 프로퍼티를 가질 수 있기 때문에 프로퍼티들을 위한 영역을 확보한다.
    - 변수처럼 데이터 공간에 할당 받은 값들을 저장하고, 그 공간에 주소값과 자신의 이름을 가지고 있는다.
- 이 프로퍼티의 위치를 알기 위해서 그 주소를 데이터 공간에 넣어둔다.
- 값을 저장한 데이터 공간의 주소를 변수가 들고 있는다.

**가변 예시)**

```jsx
var obj = {
	name: 'chan',
	skill: 'js',
}
obj.skill = 'ts'
```

**과정**

- 새로운 공간에 할당된 값 `'ts'`를  저장한다.
- skill 프로퍼티가 들고 있는 값을 `'ts'`가 저장된 공간의 주소로 바꿔준다.

### Primitive type과의 차이

- Primitve type은 할당된 값이 메모리 공간에 저장되면 바꿀 수가 없기 때문에, 변수 자신이 들고 있는 값을 다른 주소로 바꿔야했다.
- Object가 할당된 변수는 자신의 값을 그대로 들고 있으면서 내부 프로퍼티가 가르키는 값을 변경한다.

**이런 차이를 두고 Object는 가변(mutable)하다고 말한다.**

## const

> 의문: 상수를 선언할 때 `const`를 사용하니까, `const`로 선언하면 불변하지 않을까?
> 

**우선 결론은 X이다.**

- `const` 선언은 값에 대한 **읽기 전용 참조**를 만든다.
    - 메모리 상의 변수는 값으로 어떤 공간의 주소를 가지고 그 주소를 통해 할당된 값에 접근한다.
    - 변수가 들고 있는 값이 수정할 수 없는 **읽기 전용**이라는 것이다.
    - 변수가 들고 있는 값을 변경하지 못하는 것이지 할당된 값의 불변과는 상관 없다.

- 객체를 `const`로 선언했을때 프로퍼티가 변경이 되는 이유
    - 객체 변수가 `const`로 선언되었다면, 변수가 들고있는 값은 바꾸지 못한다.
    - `const`가 내부 프로퍼티 영역까지 제한하는 것은 아니다.
    - 그래서 객체 내부 프로퍼티에 재할당은 가능하다.

## 얕은 복사와 깊은 복사

> 의문: 객체를 복사하고, 사본을 수정했을 때 왜 원본과 사본이 동시에 변경될까?
> 

**예시)**

```jsx
var obj = {
	name: 'chan',
	skill: 'js',
}

var obj2 = obj;
```

**과정**

- `obj2`와 `obj` 두 변수는 같은 값(데이터 영역의 주소)을 가지게 된다.
- 데이터는 같은 프로퍼티 영역을 가르키게 된다.
- 둘이 같은 영역을 공유하고 있어서 하나를 바꾸면 다른 하나도 바뀐다.

**깊은 복사 방법**

- 원본이 변하지 않으려면 사본이 새로운 프로퍼티 영역을 가르키게 해줘야한다.
- 그리고 내부 프로퍼티의 값을 전부 복사해 주어야 한다.
- 만약 내부 프로퍼티가 객체라면 재귀적으로 그 객체 또한 새로운 영역을 정의하고 내부의 값을 전부 복사해 주어야한다.

**깊은 복사 코드 예시**

```jsx
const copyObject = (target) => {
	const result = {};
	if (typeof target === 'object' && target !== null) {
		// 객체면, 재귀 호출로 깊은 복사
		for (let prop in target) {
			result[prop] = copyObject(target[prop];
		}
	} else {
		// 객체가 아니면, 바로 복사
		result = target;
	}
	return result;
}
```

## 정리

- 변수와 값은 별개다.
    - 할당된 primitive type 값이 메모리에 저장되면,
    저장된 값을 바꿀 수 없는 것을 **불변하다**고 한다.
    - Object 변수가 들고 있는 값을 바꾸지 않으면서,
    내부 프로퍼티에 재할당할 수 있는 것을 **가변하다**고 한다.
- `const` 선언과 값의 불변은 다르다.
    - `const`는 **변수 메모리 공간의 값**을 **읽기 전용**으로 선언하는 것이다.
- 객체의 원본을 지키기 위해서는 **깊은 복사**가 필요하다.
    - 프로퍼티 영역을 가리키는 변수의 값만 복사하면, 원본과 사본이 같은 영역을 공유하는 상황이 생긴다.