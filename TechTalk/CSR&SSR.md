# CSR&SSR

[[10분 테코톡] 🎨 신세한탄의 CSR&SSR](https://www.youtube.com/watch?v=YuqB8D6eCKE&list=PLkfxusmKmLsNDGmER2tmrslpPOTfKhE7j&index=108&t=3s)

## SPA와 MPA

- SPA : 오늘날 웹 어플리케이션을 개발하면 리액트, 앵귤러, 뷰와 같은 JS 기반 SPA(Single Page Application)을 만든다.
    - Header와 Sidebar같은 부분은 고정되어 있고, 필요한 부분만 업데이트 하는 방식이 SPA이다.
- MPA : 탭을 이동할 때마다 새로 HTML을 받아서 업데이트하는 방법을 사용하는 전통적인 방식이다.
    - 매번 새로운 HTML을 받아와서 전환 시마다 화면이 깜빡인다.
    - AJAX가 등장하면서 SPA가 주류가 되었다.
    

### CSR과 SSR - SPA, MPA와의 관계

- 일반적으로 SPA에서는 CSR, MPA에서는 SSR 방식을 렌더링 방식으로 사용한다.
    - SPA
        - 웹 애플리케이션이 필요한 정적 리소스를 초반에 모두 다운받는다.
        - 이후 새로운페이지 요청이 있을 때 페이지 갱신에 필요한 데이터만 전달받아서 클라이언트에서 페이지를 갱신한다.
    - MPA
        - 새로운 요청이 있을 때 마다 서버에서 이미 렌더링된 정적 리소스를 받아온다.
        - 그래서 SSR방식을 사용한다.

- 특별한 목적을 가지고 렌더링 방식을 변경하지 않으면 다음과 같은 렌더링 방식을 사용한다.
    - CSR : 리액트, 앵귤러, 뷰
    - SSR : PHP, JSP
- 이러한 특징때문에 SPA는 CSR, MPA는 SSR이라는 공식이 적용된다고 오해할 수 있다.
    - 렌더링을 어디서 하냐, 페이지가 몇 개냐에 따라 달라지는 다른 개념이다.

## CSR과 SSR의 개념 + SSG

- CSR (Client Side Rendering)
    - 클라이언트 측에서 렌더링 하는 방식
- SSR (Server Side Rendering)
    - 서버 축에서 렌더링 하는 방식
    - 요청시 서버에서 HTML을 만들어서 응답하기 때문에 데이터가 달라지거나 자주 바뀌어서 미리 만들어 두기 어려운 페이지에 적합하다.
- SSG (Static Site Generation) or Static Rendering
    - 서버에서 HTML을 보내준다는 측면에서는 SSR과 비슷하다.
    - 서버에서 미리 페이지를 만들어 두고 요청시에 해당 페이지를 응답하기 때문에 바뀔 일이 거의 없는 페이지에 적합하다.

## CSR의 동작 과정

1. 유저가 웹사이트에 방문
2. 브라우저가 서버로 콘텐츠를 요청
3. 서버는 빈 뼈대만 있는 HTML을 응답하고 보냄
4. 브라우저가 연결된 JS링크를 통해 서버로 부터 JS파일을 다운
5. JS를 이용해 동적으로 페이지를 만들어서 렌더링

**특징**

- CSR은 JS파일을 받아 동적으로 페이지를 띄운다.
- 브라우저가 JS 파일을 다운로드 받고 동적으로 DOM 생성하는 시간을 기다려야한다.
    - 초기로딩 속도가 느리다.
    - 이후에는 필요한 데이터만 요청하면 돼서 이후 구동 속도는 빠르다.
- 서버가 빈 뼈대만 넘겨주면 돼서 서버 측의 부하가 적다.
- 클라이언트 측에서 연산, 라우팅 등을 직접 처리해서 반응 속도가 빠르고 UX가 우수하다.
- 브라우저들이 가진 웹 크롤러는 비어있는 HTML이 있기 때문에 SEO에 불리하다.
    - Googlebot은 JS파일도 실행이 가능해서 CSR도 크롤링을 할 수 있다.
    - 하지만 아직 완벽한 수준은 아니다.

## SSR의 동작 과정

1. 유저가 웹사이트에 방문
2. 브라우저에서 서버로 콘텐츠를 요청
3. 서버에서 페이지에 필요한 데이터를 모두 삽입하고 렌더링 준비가 마친 CSS코드를 적용시킨 HTML, JS코드를 브라우저에 응답으로 전달
4. 바로 전달받은 페이지를 띄움
5. 브라우저가 JS코드를 다운로드
6. HTML에 JS로직을 연결

**특징**

- 모든 데이터가 이미 HTML에 담겨진채로 브라우저에 전달되어 SEO에 유리하다.
    - JS를 실행하지 못하는 크롤러 봇도 HTML을 읽을 수 있기 때문
- JS코드를 다운받고 실행하기 전에 사용자가 화면을 볼 수 있다.
    - 초기 구동 속도가 빠르다.
    - JS코드를 다운받고 HTML에 연결하기 전까지는 사용자가 버튼을 클릭하거나 이동하려고 해도 인터렉션이 불가능하다.
    - TTV(Time to View)와 TTI(Time to Interaction)이 다르다는 것이 단점

## CSR과 SSR의 장단점

|  | CSR | SSR |
| --- | --- | --- |
| 장점 | 1. 화면 깜빡임이 없음
2. 초기 로딩 이후 구동 속도가 빠름
3. TTV와 TTI 사이 간극이 없음
4. 서버 부하 분산 | 1. 초기 구동 속도가 빠름
2. SEO에 유리함 |
| 단점 | 1. 초기 로딩 속도가 느림
2. SEO에 불리함 | 1. 화면 깜빡임이 있음
2. TTV와 TTI 사이 간극이 있음
3. 서버 부하가 있음 |

## CSR의 단점 보완 방법

- 초기 로딩 속도를 보완
    - Code Splitting
    - Tree-Shaking
    - Chunk 분리
- SEO에 약함
    - Pre-Rendering
        - 각 페이지에 대한 HTML 파일을 미리 생성 해둔 뒤 서버에서 요청하는 자가 만약 크롤러라면 사전에 렌더링된 HTML 페이지를 보여준다.
- SSR이나 SSG를 도입하면 두 단점 모두 상단부분 보완할 수 있다.

## CSR + SSR/SSG 도입 방법

**Without Framework**

- 프론트엔드 개발자에게 친숙한 express.js로 별도의 서버를 직접 운영하는 방법
- TypeScript 설정이 걱정되면 NEST.js를 사용
    - 서버 환경 구성이나 빌드등의 과정이 친숙하지 않은 프론트엔드 개발자에게 생소할 수 있음

**With Framework**

- NEXT.js는 리액트에서 SSR or SSG를 사용할 수 있게 해준는 Framework
    - 페이지의 성격별로 SSR or SSG를 설정
- Gatsby 페이지가 적고 작은 사이트라면 좋음
    - SSG에 최적화
    - CSR, SSR, Lazy loading 등도 지원
    - 다양한 플러그인 존재
- Nuxt.js는 뷰를 위한 Framework
- Angular Universal은 앵귤러에서 SSR을 가능하게 한다.
    - Angular4에서 부터는 기본 포함되어 있음

## Isomorphic App, Universal Rendering

- 초기 렌더링은 SSR을 사용하고, 이후에는 CSR을 사용하는 방식을 부르는 용어
    - Isomorphic(같은 모양의, 동일 구조의, 등정형의) App
        - 서버와 클라이언트에서 동일한 코드가 동작하는 애플리케이션이라고 해석할 수 있다.
        - 초기 로딩 속도 보안
        - SEO 개선
        - CSR의 장점이 있음

## CSR, SSR, SSG, Universal - 무엇을 써야할까

- CSR
    - 유저랑 상호작용이 많을 때
    - 대부분의 고객 개인 정보로 이루어진 페이지들이라 검색 엔진에 노출이 필요 없을 때
- SSR
    - 회사 홈페이지에서 상위에 노출되어야 할 때
    - 누구에게나 같은 내용을 보여줄 때
    - 페이지 데이터가 자주 바뀌면
- SSG
    - SSR에서 내용을 거의 업데이트하지 않으면
- Universal
    - 사용자에 따라서 페이지 내용이 달라진다.
    - 빠른 인터랙션이 중요하다.
    - 상위 노출되어야한다.