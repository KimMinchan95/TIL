# State: A Component's Memory

- 컴포넌트는 상호 작용의 결과로 화면에 표시되는 내용을 변경해야 한다.
- 컴포넌트들은 현재의 입력 값, 이미지, 쇼핑 카트와 같은 것들을 "기억"해야 한다.
  - React에서는 이러한 컴포넌트별 메모리를 상태(state)라고 한다.

## When a regular variable isn’t enough

- 지역 변수는 렌더링 간에 유지되지 않는다. React는 컴포넌트를 다시 렌더링 할 때 처음부터 렌더링한다. 지역 변수에 대한 변경 사항은 고려되지 않는다.
- 지역 변수를 변경해도 렌더링이 발생하지 않는다. React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못한다.

<br />

**컴포넌트를 새로운 데이터로 업데이트하기 위해 2가지 과정이 필요하다**

1. 렌더링 간에 데이터를 **유지**한다.
2. React 컴포넌트를 새 데이터로 렌더링하게 만든다.(리 렌더링).

<br />

**`useState` 훅은 두 가지 기능을 제공한다**

1. 상태 변수를 렌더링 간에 유지시킨다.
2. 변수를 업데이트하고 React에게 컴포넌트를 리렌더링하게 만드는 상태 setter 함수를 제공한다.

## Meet your first Hook

- React에서 `useState`를 포함해서 "use"로 시작하는 함수를 Hook이라고 한다.
- Hook은 React가 렌더링하는 동안에만 사용할 수 있는 특수한 함수이다.
  - 다양한 React 기능들을 "연결(hook into)"할 수 있다.

**주의**

- Hook(`use`로 시작하는 함수)들은 최상위 수준에서만 호출할 수 있다.
  - 조건, 루프 또는 기타 중첩 함수 내에서 Hook들을 호출할 수 없다.
- Hook은 함수이지만 컴포넌트의 요구에 대해 무조건적인 선언이라고 생각하면 유용하다.(?)
- `import` 모듈이 파일 최상위에 있는 것 처럼 `use` 기능들을 컴포넌트의 최상위에 위치시켜야 한다.

## Anatomy of `useState` (`useState` 해부학)

- `useState`를 호출하면, React에게 어떤것을 기억하라고 말하는 것이다.

**Note**

- 이름을 `const [something, setSomething]`처럼 지정하는 관습은 프로젝트 전반에 걸쳐 상황을 더 쉽게 이해할 수 있게 한다.

<br />

- `useState`의 유일한 인수는 상태 변수의 초기 값이다.
- 컴포넌트가 렌더될 때마다, `useState`는 두 개의 값을 포함한 배열을 제공한다.

1. 당신이 저장한 **상태 변수**
2. React에게 컴포넌트를 렌더링 하라고 명령하고 상태를 업데이트 할 수 있는 **상태 setter 함수**

## Giving a component multiple state variables

- 한 컴포넌트의 원하는 만큼의 상태 변수를 가질 수 있다.

## State is isolated and private

- 상태는 컴포넌트별로 지역적이다.
- 즉, 동일한 구성 요소를 두 번 렌더링하면 각 복사본은 완전히 격리된 상태가 된다.
  - 둘 중 하나를 변경해도 다른 하나에는 영향을 주지 않는다.
- 이것이 상태를 모듈 최상단에 선언할 수 있는 일반 변수와 다르게 만드는 이유이다.
  - 상태는 특정 함수 호출이나 코드의 특정 위치에 연결되지 않지만, 화면의 특정 위치에 "지역적"으로 된다.

<br />

- Props와 다르게 상태는 이를 선언하는 구성요소에 대해 완전히 비공개이다.
- 상위 구성 요소에서 변경할 수 없으며, 나머지 컴포넌트에 영향을 주지 않고 컴포넌트에 상태를 추가하거나 제거할 수 있다.
- 만약 두 자식 컴포넌트의 상태를 일치시키기 원하면 하위 컴포넌트에 상태를 제거하고 가장 가까운 부모 컴포넌트에 추가하면 된다.
