# Choosing the State Structure

- 상태를 잘 구조화하면 수정 및 디버깅하기 좋은 컴포넌트와 지속적으로 버그를 유발하는 컴포넌트의 차이를 만들 수 있다.

## Principles for structuring state

- 어떤 상태를 가지고있는 컴포넌트를 작성할때, 상태 변수의 수와 데이터의 모양을 선택해야 한다.

<br />

#### 더 나은 상태 구조를 만드는 원칙

1. **그룹 관련 상태.** 둘 이상의 상태 변수를 동시에 업데이트하는 경우 하나의 상태 변수로 통합하는 것이 좋다.
2. **상태 모순을 피하라.** 여러개의 상태가 서로 모순되고 "불일치"할 수 있는 방식으로 구성될 때, 실수할 여지를 남긴다. 이걸을 피하라
3. **중복 상태를 방지하라.** 렌더링하는 동안 컴포넌트의 특성 또는 기존 상태 변수에서 일부 정보를 계산할 수 있는 경우 해당 상태를 추가적으로 생성하지 말아라.
4. **상태의 중복을 방지하라.** 여러 상태 변수 간에 또는 중첩된 객체 내에서 동일한 데이터가 중복되는 경우 동기화를 유지하기 어렵다. 가능한 경우 중복을 줄여라.
5. **중첩된 상태를 방지하라.** 깊은 계층적 상태는 업데이트하기에 매우 어렵다. 가능하면 상태를 평평하게 구성하라(1차원 배열, 객체).

## Group related state

- 단일 또는 상태를 여러개 만들지 확실할 수 없는 경우가 있다.
- 일부 두 상태 변수가 항상 함께 변경되는 경우 단일 상태 변수로 통합하는 것이 좋다.

**예시**

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

때때

## Avoid contradictions in state

- `isSending`과 `isSent`라는 상태 변수를 만들었을 때, 두 상태를 동시에 업데이트 하는 경우를 잊어버려서 동시에 참인 상황이 발생할 수 있다.
- 컴포넌트가 복잡할수록 디버깅하기 힘들어진다.

## Avoid redundant state

- 렌더링하는 동안 컴포넌트의 특성 또는 기존 상태 변수에서 일부 정보를 계산할 수 있는 경우 해당 정보를 컴포넌트의 상태로 전환하지 않아야 한다.

**예시**

```jsx
const fullName = firstName + ' ' + lastName;
```

## Avoid duplication in state

- 상태의 중복을 막는 것이 동기화에 유리하다.

**예시**

```jsx
// 중복된 상태 예시
items = [{ id: 0, title: 'pretzels'}, ...]
selectedItem = {id: 0, title: 'pretzels'}

// 옳은 예시
items = [{ id: 0, title: 'pretzels'}, ...]
selectedId = 0
```

## Avoid deeply nested state

- 깊이 중첩된 객체는 복사에 매우 어렵고 코드가 장황해 보인다.
- 상태가 너무 중첩되어 있어 쉽게 업데이트할 수 없는 경우 "flat"한 상태로 만드는 것이 좋다.
- 트리 구조 대신 각 객체가 하위의 id를 배열로 보유하는 것도 좋은 방법이다.
