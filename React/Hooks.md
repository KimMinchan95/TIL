> [10분 테코톡 - 우연의 Hooks](https://www.youtube.com/watch?v=evJ_O-H-EJI)를 글로 정리한 자료입니다.

### 1. Hooks란?

- React 16.8버전에서 **클래스형 컴포넌트**만을 사용할 때 부딪히는 수많은 **문제들을 해결하기 위해 나온 것** 이다.
    - 컴포넌트의 상태 로직 재활용이 어려움
        - 관심사 분리가 제대로 되지 않고 컴포넌트 간의 중복이 상당히 많아져 규모가 큰 컴포넌트들가 만들어짐
        - 유지보수가 상당히 어려워졌고 테스팅 또한 어려워졌다.
    - 클래스는 혼란을 줄 수 있다.
        - 클래스 컴포넌트의 방식이 너무 복잡하고, 클래스의 this는 동작방식이 다양하다보니 예상치 못한 오류를 발생시킬 수도 있다.

⇒ 함수를 이용하고 싶지만, 함수는 상태를 가지지 못한다는 문제점 때문에 클래스를 이용하고 있었다.

> **함수가 상태를 가지지 못하는 이유**
→ 함수형 컴포넌트들은 기본적으로 리렌더링이 될때, 함수 안에 작성된 모든 코드가 다시 실행된다.
→ 이는 함수형 컴포넌트들이 기존에 가지고 있던 상태(state)를 전혀 관리(기억)할 수 없게 만든다.
> 

> **Hooks를 사용하면 함수가 상태를 가질수 있는 이유**
리액트는 `useState`를 통해 생성한 상태에 접근하고 유지하기 위해서
**Clousre을 이용하여 함수형 컴포넌트 바깥에 state를 저장**한다.
그래서 상태가 업데이트 되었을 때, 이 상태들은 리액트 컴포넌트 바깥에 선언되어 있는 변수들이기 때문에 업데이트 한 후에도 이 변수들에 접근할 수 있게 된다.
> 

### 2. Hooks 종류 - useState

함수 컴포넌트 안에서 **state**를 사용할 수 있다.

### 3. Hooks 종류 - useEffect

함수 컴포넌트 안에서 **side effect**를 수행할 수 있게한다.

> **Side effect**
함수가 실행되면서 함수 외부에 존재하는 값이나 상태를 변경시키는 등의 행위
> 
- Class의 **Lifecycle**와 유사한 기능

- `useEffect`가 클래스형 컴포넌트에 있는 모든 생명 주기를 표현할 수는 없음
    - getDerivedStateFromError
    - componentDidCatch

등은 `useEffect`로 나타낼 수 없다.

### 3. Hooks 규칙

1. 최상위에서만 Hook을 호출
- React 함수(컴포넌트)의 최상위에서만 Hook을 호출 할 것
- 이 규칙을 따라야 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 Hook이 호출되는 것이 보장된다.
1. React 함수에서만 Hook을 호출
- Custom Hook에서는 호출 가능
- 일반적인 Javascript 함수에서는 호출 X
- 이 규칙을 지키면 컴포넌트의 모든 상태 관련 로직을 소스코드에서 명확하게 보이도록 할 수 있다.
1. Hook을 만들 때 앞에 use를 붙이기
- 한눈에 보아도 Hook 규칙이 적용되는지를 파악할 수 있기 떄문이다.
- 이를 따르지 않으면 특정한 함수가 그 안에서 Hook을 호출하는지를 알 수 없기 때문에 Hook 규칙의 위반 여부를 체크할 수 없다.

### 4. Custom Hook

- Custom Hook은 React의 특별한 기능이라기보다 기본적으로 **Hook의 디자인을 따르는 관습**이다.
- Custom Hook의 사용으로 중복된 로직을 재활용할 수 있다.
- 리액트 공식문서에서는 **복잡한 로직을 단순한 인터페이스 속에 숨길 수 있도록** 하거나 **복잡하게 뒤엉킨 컴포넌트를 풀어내도록 도울 때** Custom Hook을 사용하는 것을 권장한다.
